{
  "clara_app/export_zipfile_views.py": [
    {
      "created_at": "2025-12-22T09:35:52.835915+00:00",
      "model": "gpt-5.2",
      "usage": {
        "model": "gpt-5.2",
        "prompt_tokens": 5529,
        "completion_tokens": 885,
        "total_tokens": 6414,
        "estimated_cost_usd": 0.022065750000000002
      },
      "analysis": {
        "proposed_docstring": "Views for exporting C-LARA data into portable filesystem bundles.\n\nThis module implements three export workflows:\n\n1) Single-project export (role-guarded): starts an async Django-Q task to build a project export zip via clara_export_import.make_export_zipfile_internal, streams progress through the task-update mechanism (make_asynch_callback_and_report_id + post_task_update), exposes a JSON polling endpoint for the browser, and renders monitor/complete pages. When S3-backed storage is enabled, the completion view can return a presigned download URL for the generated zip path.\n\n2) Bulk export of project source zips (admin-only): enqueues an async task that iterates over CLARAProject rows (optionally filtered by only_ids/skip_ids), writes one subdirectory per project under a destination root, copies the generated source zip into <project_id>/source.zip, and writes per-project metadata plus batch-level index.json and failures.json.\n\n3) Bulk export of audio repository content (admin-only): enqueues an async task that walks AudioMetadata rows (optionally filtered by engine/language/voice), copies referenced audio files into an output tree grouped by engine_id/language_id/voice_id, and writes a manifest.json per group plus batch-level index.json and failures.json.\n\nAll long-running work is performed in background tasks and reported to the UI via TaskUpdate polling endpoints; monitor templates are expected to poll the corresponding *_status views until a terminal marker (\"finished\" or \"error\") is observed.",
        "short_summary": "This module provides Django views to export C-LARA projects and audio assets into portable bundles on disk. It supports a role-protected single-project export zip workflow and two admin-only bulk export workflows (project source zips and audio repository exports). All exports run asynchronously via Django-Q and report progress through a report_id-based task update stream that the UI polls.",
        "key_responsibilities": [
          "Start single-project export zip creation as an async Django-Q task and redirect to a monitor page",
          "Provide JSON polling endpoints that return task update messages and a derived status (unknown/finished/error)",
          "Render monitor and completion templates for export workflows, including optional S3 presigned download URLs for project zips",
          "Run admin-only bulk source exports: generate per-project source.zip + metadata.json and batch index/failures summaries",
          "Run admin-only bulk audio exports: copy audio files grouped by (engine_id, language_id, voice_id) and write per-group manifests plus batch summaries",
          "Provide helper utilities for clearing output directories and computing SHA-256 checksums for exported artifacts"
        ],
        "potential_issues": [
          "Status detection is message-substring based (e.g., any message containing \"error\"), which can misclassify status if unrelated text includes that substring; single-project status checks for exact membership ('error' in messages) while bulk checks substring, leading to inconsistent behavior.",
          "make_export_zipfile_status prints to stdout on every poll, which can spam logs in production and leak operational details.",
          "start_bulk_source_exports passes dest_root through the URL and later uses it directly as a filesystem path; this can be risky if URL routing allows arbitrary paths (path traversal / unexpected locations) and should be validated/normalized server-side.",
          "bulk_audio_export_complete ignores any custom output root (it always reads $CLARA/tmp/bulk_audio_exports), so the completion page may not reflect where the task actually wrote data if that ever becomes configurable.",
          "export_all_project_zips_task converts QuerySets to Python lists when applying only_ids/skip_ids, which can load all projects into memory and be slow on large databases; filtering should ideally be done at the database level.",
          "Bulk source export always writes failures.json (even empty), while bulk audio export writes failures.json only on failures; downstream tooling should not assume consistent presence.",
          "export_all_project_zips_task reads the generated zip into memory (read_bytes/write_bytes) before writing to destination; large zips could cause high memory usage and should be streamed/copied instead.",
          "_clear_dir suppresses all exceptions silently, which can leave partial state without reporting; tasks may claim success while output directories were not actually cleared."
        ]
      }
    },
    {
      "created_at": "2025-12-22T12:20:18.331671+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5529,
        "completion_tokens": 1912,
        "total_tokens": 7441,
        "estimated_cost_usd": 0.026031250000000002
      },
      "analysis": {
        "proposed_docstring": "Views for packaging and exporting C-LARA content into portable bundles. This module drives three asynchronous workflows: single-project export zips for project members, bulk source exports of all projects, and bulk audio exports of repository content. It wires up start/monitor/status/complete pages, dispatches long-running tasks via django-q, streams progress via task updates, and writes manifest/index files alongside the exported archives.",
        "short_summary": "This views module orchestrates creation of export bundles for C-LARA projects and audio. It provides protected endpoints to kick off async packaging jobs, polls task updates, and renders monitor/complete pages. Bulk exports iterate over all projects or audio metadata, write out zips and manifests, and record index/failure summaries.",
        "key_responsibilities": [
          "Initiate single-project export zip creation with role-guarding, enqueue async tasks, and render status/complete pages with optional S3 presigned download links.",
          "Provide admin-only bulk source export flow: collect filters, start a background job to zip each project into a directory tree, and summarize successes/failures.",
          "Provide admin-only bulk audio export flow: copy repository audio grouped by engine/language/voice, emit manifests and index files, and report outcomes.",
          "Expose JSON status endpoints that poll task updates and derive simple finished/error/unknown states for front-end monitors."
        ],
        "potential_issues": [
          "Single-project status detection checks for exact 'error' or 'finished' messages; non-exact error texts may leave status 'unknown'.",
          "Bulk status endpoints flag any message containing 'error', which may produce false positives on benign messages mentioning errors.",
          "bulk_audio_export_complete reads from a hardcoded CLARA tmp path; if export destinations ever become configurable, summaries may point to the wrong directory.",
          "Destination roots for bulk source exports are passed via URL parameters; although admin-only, unvalidated paths could expose or clobber arbitrary directories.",
          "_clear_dir silently ignores deletion errors, which can leave stale files and ambiguous results on subsequent runs."
        ]
      }
    },
    {
      "created_at": "2025-12-22T19:49:33.821417+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5529,
        "completion_tokens": 798,
        "total_tokens": 6327,
        "estimated_cost_usd": 0.014891249999999998
      },
      "analysis": {
        "proposed_docstring": "Views for packaging and exporting C‑LARA project data and audio into portable bundles. This module exposes UI endpoints to kick off asynchronous export jobs (single project zip, bulk source exports, bulk audio exports), monitor their progress via task update polling, and present completion summaries or download links. It orchestrates Django‑Q tasks that invoke internal export helpers, writes index/manifest metadata alongside exported content, and enforces project membership or admin access as appropriate.",
        "short_summary": "This module implements the web workflows for exporting C-LARA projects and audio into zipfiles or directory trees. It wires up form submissions to asynchronous Django-Q tasks, supplies polling endpoints for progress, and renders monitor/complete pages. Single-project exports are role-protected, while bulk source and audio exports are admin-only, and outputs include accompanying metadata manifests.",
        "key_responsibilities": [
          "Start and monitor an async task to build a single project export zip, then render completion with optional S3 presigned URL.",
          "Kick off bulk source exports for all (or filtered) projects, writing per-project source.zip and metadata.json plus batch index/failures, and render status/summary pages.",
          "Kick off bulk audio export tasks that copy referenced audio files grouped by engine/language/voice with manifest and index/failures, and render status/summary pages.",
          "Integrate with the task update mechanism (make_asynch_callback_and_report_id, post_task_update, get_task_updates) to report progress/errors to polling JSON endpoints."
        ],
        "potential_issues": [
          "bulk_audio_export_complete always reads from $CLARA/tmp/bulk_audio_exports via os.environ, ignoring any alternative base configured in the task helper.",
          "Error/status detection is simplistic: make_export_zipfile_status only flags exact 'error'/'finished' messages, and bulk status endpoints mark any message containing 'error' as failure (including phrases like 'finished with N errors').",
          "bulk_source_exports writes failures.json even when empty; conversely, bulk_audio_export_complete assumes index/failures files exist and may misreport if paths differ.",
          "Path handling relies on absolute_file_name and env CLARA; misconfiguration could break export destinations or presigned URL generation."
        ]
      }
    },
    {
      "created_at": "2025-12-22T19:56:11.368223+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5529,
        "completion_tokens": 937,
        "total_tokens": 6466,
        "estimated_cost_usd": 0.01628125
      },
      "analysis": {
        "proposed_docstring": "Django view layer for producing portable export bundles from a C-LARA instance. It orchestrates single-project export zip creation and bulk export jobs for project sources and audio repositories, delegating heavy work to asynchronous Django-Q tasks and exposing monitoring/status endpoints. The module wires up forms, permission checks, and template rendering for starting jobs, polling task updates, and presenting completion summaries, including S3 presigned download links when applicable. It also contains helpers to clean output directories and compute file hashes used in export manifests.",
        "short_summary": "This module exposes views to export C-LARA project data and audio content into filesystem bundles. It starts asynchronous tasks to build single-project export zipfiles, bulk source exports, or bulk audio exports, and provides polling and monitor pages to track task progress. Completion views summarize output directories and surface download URLs when using S3 storage.",
        "key_responsibilities": [
          "Start, monitor, and complete single-project export zip creation with role-based access control and optional S3 presigned download links.",
          "Handle admin-only bulk source export jobs over all or filtered projects, including directory preparation, metadata generation, and failure tracking.",
          "Handle admin-only bulk audio export jobs, grouping audio files by engine/language/voice and writing manifests and summary indices.",
          "Coordinate asynchronous task execution via Django-Q and propagate progress/final statuses through task update callbacks and JSON polling endpoints."
        ],
        "potential_issues": [
          "Status detection relies on substring checks for 'error' and 'finished', which may misclassify messages that merely contain those words.",
          "bulk_audio_export_complete always reads from $CLARA/tmp/bulk_audio_exports and would not honor a different destination if that were ever made configurable.",
          "Clearing output directories in bulk exports (_clear_dir) is best-effort and silently ignores errors, potentially leaving stale files.",
          "Long-running export tasks copy entire project directories and audio repositories; large datasets may impact performance or storage and lack pagination or throttling."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:12:02.178716+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5529,
        "completion_tokens": 1924,
        "total_tokens": 7453,
        "estimated_cost_usd": 0.02615125
      },
      "analysis": {
        "proposed_docstring": "Views for packaging C-LARA content into portable bundles. Exposes UI endpoints to launch asynchronous exports of a single project zip, bulk source zips, and bulk audio repositories, with monitoring and completion pages. Uses Django-Q tasks to perform the work, reporting progress via task updates polled by JSON status endpoints, and renders templates for start, monitor, and completion workflows. Access is restricted to project members for single-project exports and to admins for bulk operations, with optional S3 presigned URL support when serving generated zipfiles.",
        "short_summary": "This module implements Django views to export C-LARA projects and audio into zipfiles or directory trees. It orchestrates asynchronous tasks via django-q, provides polling endpoints for progress, and renders monitor and completion pages. Single-project exports are guarded by project membership, while bulk source and audio exports are admin-only and write manifests and indices to filesystem paths.",
        "key_responsibilities": [
          "Start, monitor, and complete asynchronous creation of a single project export zipfile, including optional S3 download links.",
          "Admin-only bulk export of all project source zips with metadata, index, and failure reporting to a destination root.",
          "Admin-only bulk export of audio repository content grouped by engine/language/voice, producing manifests, indices, and failure logs.",
          "Expose JSON status endpoints that poll task update records and render associated monitoring and completion templates."
        ],
        "potential_issues": [
          "Status detection for bulk exports treats any message containing the substring \"error\" as a failure; messages like \"finished with N errors\" will force an error state and other incidental occurrences could misclassify status.",
          "bulk_audio_export_complete assumes the output root at $CLARA/tmp/bulk_audio_exports regardless of configuration; if the CLARA environment variable is unset or a different output path is desired, the view may not find results.",
          "_clear_dir ignores cleanup errors silently, so stale files or partial deletions may go unnoticed before writing new exports.",
          "Destination roots or filenames containing unusual characters may not round-trip cleanly through URL parameters when passing dest_root to monitor/complete views."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "start_bulk_source_exports",
          "args_raw": [],
          "href_expr": "{% url 'start_bulk_source_exports' %}",
          "element": "a",
          "attr": "href",
          "title": "Create a directory containing zips of all projects plus metadata.",
          "text": "Prepare zipfiles of all projects",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.export_zipfile_views.start_bulk_source_exports"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "bulk_audio_export_start",
          "args_raw": [],
          "href_expr": "{% url 'bulk_audio_export_start' %}",
          "element": "a",
          "attr": "href",
          "title": "Create a directory containing all audio plus metadata.",
          "text": "Prepare downloadable directory of audio for all projects",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.export_zipfile_views.start_bulk_audio_export"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "make_export_zipfile",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'make_export_zipfile' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Export zipfile",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.export_zipfile_views.make_export_zipfile"
        }
      ]
    }
  ],
  "clara_app/accounts_views.py": [
    {
      "created_at": "2025-12-22T19:51:54.538718+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 524,
        "completion_tokens": 855,
        "total_tokens": 1379,
        "estimated_cost_usd": 0.009205
      },
      "analysis": {
        "proposed_docstring": "Provides the custom account views for C-LARA, handling user registration and profile display while relying on Django’s built-in authentication for login/logout. The register view validates and creates a new user along with associated profile and configuration records, then redirects to the login screen. The profile view requires authentication, ensures a profile exists, pulls user configuration (including the Clara version), and renders the profile template with user details.",
        "short_summary": "This module defines the account-related views beyond Django’s built-in login/logout. It implements a registration workflow that saves a user, creates a profile and configuration, and shows success feedback. It also exposes an authenticated profile view that ensures the profile exists and renders user and configuration data.",
        "key_responsibilities": [
          "Handle user registration via a RegistrationForm, persisting the new user and creating related UserProfile and UserConfiguration records.",
          "Provide an authenticated profile view that retrieves or creates the user’s profile and reads configuration values for display.",
          "Render appropriate templates for registration and profile, and use Django messages for user feedback."
        ],
        "potential_issues": [
          "The register view saves the user twice and manually sets the email, which may be redundant if the form already includes that field.",
          "No transaction is used during registration; if creating the profile or configuration fails, a user could be created without associated records.",
          "The profile view assumes get_user_config returns a dict containing 'clara_version'; missing keys or configuration retrieval failures could raise errors.",
          "Registration does not log the user in after creation, which may or may not be intended."
        ]
      }
    },
    {
      "created_at": "2025-12-23T11:37:15.233576+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 524,
        "completion_tokens": 1071,
        "total_tokens": 1595,
        "estimated_cost_usd": 0.011364999999999998
      },
      "analysis": {
        "proposed_docstring": "Views module handling user registration and profile display for the Clara app, complementing Django's built-in authentication. It renders a registration form, creates associated profile and configuration records on signup, and exposes a login-protected profile view that shows account details and user-specific Clara configuration.",
        "short_summary": "This module defines custom views around user signup and profile display, leaving login/logout to Django's built-in auth views. The registration view processes a RegistrationForm, saves the user, and initializes related UserProfile and UserConfiguration records before redirecting to login. The profile view ensures a profile exists and renders it along with email and Clara version information. Templates under `clara_app` are used to render both pages and success messages are flashed on successful registration.",
        "key_responsibilities": [
          "Render and process the user registration form, creating a new user account.",
          "Initialize linked UserProfile and UserConfiguration objects upon successful signup.",
          "Provide a login-protected profile view that retrieves or creates a UserProfile and displays email and Clara version from user configuration.",
          "Interact with Django messaging and template system to deliver feedback and UI."
        ],
        "potential_issues": [
          "The code manually sets and saves the user's email after `form.save()`, which may be redundant if the form already handles email.",
          "UserConfiguration is only created at registration; if missing for an existing user, `get_user_config` might fail or lack a `'clara_version'` key.",
          "Registration view redirects to login without logging the user in or providing feedback on invalid submissions beyond the form errors.",
          "No `get_or_create` is used for UserConfiguration in the profile view, so missing configs could raise errors."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "profile",
          "args_raw": [],
          "href_expr": "{% url 'profile' %}",
          "element": "a",
          "attr": "href",
          "title": "Display your location, bio, profile picture etc.",
          "text": "Display user profile",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.accounts_views.profile"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "register",
          "args_raw": [],
          "href_expr": "{% url 'register' %}",
          "element": "a",
          "attr": "href",
          "title": "Create a new account, giving a userid, password and email address.",
          "text": "Sign up",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.accounts_views.register"
        }
      ]
    }
  ],
  "clara_app/activity_tracker_views.py": [
    {
      "created_at": "2025-12-22T19:52:18.331974+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4199,
        "completion_tokens": 2408,
        "total_tokens": 6607,
        "estimated_cost_usd": 0.02932875
      },
      "analysis": {
        "proposed_docstring": "Views for managing the C-LARA activity tracker, covering creation, detail display and updates, listing with filtering and scoring, notifications, and administrative integrations. It handles activity creation, comment submission, registration/unregistration, status/resolution changes, and voting (including current vote scoring), and renders the appropriate templates with forms and context. Helper functions collect interested parties and send comment notification emails. Admin-only endpoints provide a plain-text summary feed and process AI-generated activity updates and votes, using transactions and messaging to report outcomes.",
        "short_summary": "This module defines Django views for creating, viewing, updating, and listing tracked activities in the C-LARA app. It manages comments, registrations, status/resolution updates, and votes, updating timestamps and notifying participants by email when needed. Admin-only views expose a text summary endpoint and a handler for ingesting AI-supplied activity updates and votes.",
        "key_responsibilities": [
          "Render activity creation form, persist new activities with the current user as creator, and redirect to detail pages.",
          "Display activity details with associated comments, registration status, status/resolution forms, and voting controls, handling updates to each via POST.",
          "Send notification emails to creators, voters, and commenters (respecting opt-out flags) when new comments are added.",
          "List and filter activities, annotate them with a vote-based score and custom status ordering, and render either HTML or an admin-only plain text summary.",
          "Ingest admin-submitted AI updates to create comments or new activities and record AI user votes, maintaining per-week vote uniqueness."
        ],
        "potential_issues": [
          "create_activity does not return a response when a POSTed form is invalid, which will cause a 500 error instead of re-rendering the form.",
          "Several permission checks assume a userprofile with an is_admin attribute exists; missing profiles could raise AttributeError.",
          "AI update processing assumes the JSON structure contains expected keys and that referenced activity IDs exist; malformed data will trigger generic exceptions.",
          "Notification recipient filtering only considers ActivityRegistration opt-outs; unregistered users who have voted or commented will be emailed unless otherwise handled.",
          "Activity list filtering prioritizes id over other filters and silently ignores invalid search forms, which may surprise users; week_start is computed in some views but unused."
        ]
      }
    },
    {
      "created_at": "2025-12-23T11:38:38.630195+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4199,
        "completion_tokens": 3691,
        "total_tokens": 7890,
        "estimated_cost_usd": 0.042158749999999995
      },
      "analysis": {
        "proposed_docstring": "Views for the activity tracker: handle creation of new activities, display and update of individual activity records with comments, registrations, voting, status and resolution changes, and notification of participants by email. Provides list views for browsing activities, including an admin-only plain text summary intended for AI integration, and accepts AI-generated updates, comments, new activities and votes. Utilities are provided to annotate and order activity querysets for display and to enforce weekly voting uniqueness via get_zoom_meeting_start_date.",
        "short_summary": "This module defines Django views for creating, viewing, updating, and listing activities within the application. It supports commenting, registration, status/resolution changes, and weighted voting on activities, and sends email notifications to relevant users when new comments are posted. Admin-only views provide a plain text summary for AI consumption and accept AI-submitted activity updates and votes. Helpers annotate activity querysets with vote scores and status ordering for display.",
        "key_responsibilities": [
          "Create new activities via ActivityForm and redirect to detail views",
          "Render activity detail pages with commenting, registration, status/resolution updates, and vote handling tied to weekly periods",
          "Notify activity creators, voters, and commenters of new comments via email templating and environment-aware sending",
          "List activities with search/filter options and annotate them with vote scores and status ordering for display",
          "Provide an admin-only plain text activity summary with instructions/examples for AI updates, and process AI-submitted comments, new activities, and votes"
        ],
        "potential_issues": [
          "create_activity does not render the form with errors on invalid POST and may return None, leading to a server error",
          "activity_detail can fall through on a POST with invalid form data and attempt to render without initializing required context variables (UnboundLocalError), and the vote branch redirects even when the form is invalid, hiding errors",
          "ai_activities_reply assumes a user named 'ai_user' and a well-formed updates_json payload; missing users or keys will raise exceptions, and broad exception handling may mask specific failures",
          "The uniqueness check for vote importance relies on Application logic; without database constraints, duplicate importance votes could slip through under concurrent requests",
          "list_activities_text defines week_start but does not use it; filtering logic differs slightly from list_activities"
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "list_activities",
          "args_raw": [],
          "href_expr": "{% url 'list_activities' %}",
          "element": "a",
          "attr": "href",
          "title": "List ongoing project activities or register a new activity.",
          "text": "Project activities",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.activity_tracker_views.list_activities"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "list_activities_text",
          "args_raw": [],
          "href_expr": "{% url 'list_activities_text' %}",
          "element": "a",
          "attr": "href",
          "title": "List ongoing project activities in plain text form. Mainly for AI.",
          "text": "Activities (plain text version)",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.activity_tracker_views.list_activities_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "ai_activities_reply",
          "args_raw": [],
          "href_expr": "{% url 'ai_activities_reply' %}",
          "element": "a",
          "attr": "href",
          "title": "Post a JSON structure written by the AI, which updates the activities.",
          "text": "Post AI updates to activities",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.activity_tracker_views.ai_activities_reply"
        }
      ]
    }
  ],
  "clara_app/admin_permission_views.py": [
    {
      "created_at": "2025-12-22T19:52:36.024761+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1261,
        "completion_tokens": 1804,
        "total_tokens": 3065,
        "estimated_cost_usd": 0.019616250000000002
      },
      "analysis": {
        "proposed_docstring": "Admin-facing Django views for managing user permissions and project ownership within the CLARA application. It exposes handlers to reset another user's password, grant oneself co-ownership of projects via a search and selection formset, and select and update a user's profile permissions, all restricted to authenticated administrators. The views coordinate form processing, model updates on CLARAProject, ProjectPermissions, and UserProfile, and render the corresponding templates with status messages and user configuration context.",
        "short_summary": "This module defines administrator-only views to manage accounts and permissions in the CLARA app. It includes a password reset view, a workflow to search for projects and add oneself as a co-owner, and a two-step form to select a user and update their profile permissions. Each view relies on associated forms, displays feedback messages, and renders dedicated templates.",
        "key_responsibilities": [
          "Handle an admin password reset form to update another user's credentials and render the reset template with user configuration context.",
          "Provide a search and selection interface for projects and create ProjectPermissions entries to make the admin a co-owner of selected projects.",
          "Offer a two-stage form workflow to choose a user and edit their UserProfile permissions, persisting changes and giving feedback."
        ],
        "potential_issues": [
          "In admin_project_ownership, if a posted ProjectSelectionFormSet is invalid, the view will attempt to render without defining projects_info, leading to a NameError.",
          "The project ownership view does not check for existing ownership, so creating duplicate ProjectPermissions entries is possible.",
          "The user_passes_test lambdas assume every User has an associated UserProfile; missing profiles would raise an AttributeError.",
          "Catching User.DoesNotExist in admin_password_reset may be ineffective since the user comes from validated form data, and other failure modes (e.g., saving errors) are not handled."
        ]
      }
    },
    {
      "created_at": "2025-12-23T11:39:33.716631+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1261,
        "completion_tokens": 2665,
        "total_tokens": 3926,
        "estimated_cost_usd": 0.02822625
      },
      "analysis": {
        "proposed_docstring": "Admin-only Django views for managing user accounts, permissions, and project ownership within the CLARA application. It exposes endpoints to manually reset user passwords, search and self-assign co-ownership of projects, and select and update user profile permissions, all gated by login and an is_admin check. The views orchestrate form handling, model updates for projects and permissions, and rendering of templates with configuration details such as the CLARA version, using Django's messaging framework for user feedback.",
        "short_summary": "This module defines administrator-facing views for managing users and project permissions in the CLARA app. It allows admins to reset other users' passwords, search for projects and add themselves as co-owners, and select users to update their profile permissions. Access is restricted to logged-in users flagged as admins, and the views coordinate form validation, model updates, and template rendering with appropriate feedback.",
        "key_responsibilities": [
          "Restrict access to admin-only operations using login and user_passes_test decorators checking UserProfile.is_admin.",
          "Handle the AdminPasswordResetForm to reset another user's password and provide success/error messaging.",
          "Search and filter CLARAProject records, render a selection formset, and create ProjectPermissions entries to grant the current admin an OWNER role on chosen projects.",
          "Render a workflow to select a user and update their UserProfile permissions via UserPermissionsForm, persisting changes and redirecting on success.",
          "Supply templates with necessary context such as form instances and the current CLARA version retrieved from user configuration."
        ],
        "potential_issues": [
          "The `config` variable and logger are defined but unused, suggesting leftover or incomplete logging/configuration handling.",
          "In `admin_project_ownership`, no check prevents creating duplicate ProjectPermissions; repeated submissions could add redundant owner entries if not constrained at the model level.",
          "If the project selection formset is invalid on POST, `projects_info` is not defined before rendering, which could raise an error in the template context.",
          "The admin checks assume every user has an associated UserProfile; missing profiles would cause attribute errors in the user_passes_test lambdas.",
          "Using `CLARAProject.objects.get` without error handling in `admin_project_ownership` may raise exceptions for invalid project IDs instead of returning a 404."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "manage_user_permissions",
          "args_raw": [],
          "href_expr": "{% url 'manage_user_permissions' %}",
          "element": "a",
          "attr": "href",
          "title": "Manage permissions for funding request reviewer, moderator and admin",
          "text": "Manage permissions",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.admin_permission_views.manage_user_permissions"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "admin_password_reset",
          "args_raw": [],
          "href_expr": "{% url 'admin_password_reset' %}",
          "element": "a",
          "attr": "href",
          "title": "Manually reset a user's password, in case they cannot use the normal password reset.",
          "text": "Manually reset user's password",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.admin_permission_views.admin_password_reset"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "admin_project_ownership",
          "args_raw": [],
          "href_expr": "{% url 'admin_project_ownership' %}",
          "element": "a",
          "attr": "href",
          "title": "Give yourself a COOWNER role on a project, if you are an admin and need to access it urgently for some reason.",
          "text": "Make yourself co-owner of a project",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.admin_permission_views.admin_project_ownership"
        }
      ]
    }
  ],
  "clara_app/annotation_prompts_views.py": [
    {
      "created_at": "2025-12-22T19:53:13.082699+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2764,
        "completion_tokens": 3644,
        "total_tokens": 6408,
        "estimated_cost_usd": 0.039895
      },
      "analysis": {
        "proposed_docstring": "Views for managing editable prompt templates/examples and localisation bundles. This module lets language masters load, edit, and save prompt templates or example strings for various annotation types using dynamic formsets backed by a PromptTemplateRepository, with fallbacks to default language data. It also provides views to list localisation bundles with per-language translation progress and to edit bundle translations for permitted users, rendering the corresponding templates and surfacing success or error messages.",
        "short_summary": "This module contains Django views for editing annotation prompt templates/examples and managing localisation bundles. Language masters can select languages, annotation types, and operations to load and save prompt data via formsets with fallback loading behaviour. It also lists localisation bundles with translation counts and allows editing translations per language for users with the proper permissions.",
        "key_responsibilities": [
          "Handle the edit_prompt view to select, load, display, and save prompt templates or example strings for different annotation types and languages via appropriate formsets",
          "Coordinate loading of prompt data from language-specific or default repositories, and saving updates through PromptTemplateRepository while reporting status via Django messages",
          "List localisation bundles and compute per-language translation completion for languages the current user masters in the bundle_list view",
          "Provide an edit_bundle view to update localisation bundle translations per language, persisting changes to BundleTranslation models and rendering edit_bundle.html"
        ],
        "potential_issues": [
          "edit_bundle uses HttpResponseForbidden but does not import it, which will raise a NameError on forbidden access",
          "In the save branch for two-field StringPair prompts, the code checks new_prompts[-1][2], which will raise IndexError if both fields are present",
          "Initial data preparation for 'presegmented' annotation types differs between load and save branches (load only includes annotate or segmented), which may lead to misaligned formsets",
          "Debug print statements and unused variables/imports remain in production code, potentially cluttering logs or indicating incomplete refactoring",
          "Language column selection in bundle_list ignores languages with existing translations unless the user is a master, which may hide data unexpectedly"
        ]
      }
    },
    {
      "created_at": "2025-12-23T11:40:09.578916+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2764,
        "completion_tokens": 2441,
        "total_tokens": 5205,
        "estimated_cost_usd": 0.027865
      },
      "analysis": {
        "proposed_docstring": "Django views handling editing of annotation prompt templates/examples and localisation bundles. Provides interfaces for language masters to select, load and save prompt templates and examples via formsets backed by PromptTemplateRepository, with right-to-left support and user-specific config. Also includes list/edit views for localisation bundles and translations, enforcing permissions and rendering appropriate templates with success/error messaging.",
        "short_summary": "This module defines Django views for managing annotation prompt templates/examples and localisation translation bundles. The edit_prompt view lets language masters load or save prompt templates or example sets for various annotation types, dynamically constructing formsets and deferring persistence to a PromptTemplateRepository. The bundle_list and edit_bundle views show translation progress per bundle and allow authorised users to edit translations.",
        "key_responsibilities": [
          "Expose edit_prompt view to allow language masters to load and save prompt templates or annotation examples for a given language, annotation type and operation using dynamic formsets.",
          "Invoke PromptTemplateRepository to retrieve default or language-specific templates/examples and handle TemplateError conditions with user feedback.",
          "Render and process list/edit pages for localisation bundles, aggregating translation counts per language and persisting BundleTranslation updates.",
          "Enforce access control for language masters and translators, and use Django messages to report success or errors to the user."
        ],
        "potential_issues": [
          "edit_bundle returns HttpResponseForbidden without importing it, which will raise a NameError.",
          "In the save branch of edit_prompt for string pair formsets, it attempts to access new_prompts[-1][2] even though only two elements are collected, likely causing an IndexError.",
          "bundle_list currently uses print statements for debugging instead of the configured logger.",
          "Language column selection in bundle_list ignores existing translations (commented-out logic), potentially hiding languages with data if the user is not a master."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "bundle_list",
          "args_raw": [],
          "href_expr": "{% url 'bundle_list' %}",
          "element": "a",
          "attr": "href",
          "title": "List all localisation bundles",
          "text": "List all localisation bundles",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.annotation_prompts_views.bundle_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "edit_prompt",
          "args_raw": [],
          "href_expr": "{% url 'edit_prompt' %}",
          "element": "a",
          "attr": "href",
          "title": "Edit the GPT-4 prompt templates and examples used to create text annotations for languages where you are a language master.",
          "text": "Edit annotation prompts",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.annotation_prompts_views.edit_prompt"
        }
      ]
    }
  ],
  "clara_app/annotation_views.py": [
    {
      "created_at": "2025-12-22T19:53:37.572715+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 8646,
        "completion_tokens": 1761,
        "total_tokens": 10407,
        "estimated_cost_usd": 0.0284175
      },
      "analysis": {
        "proposed_docstring": "Views supporting creation, annotation and editing of the various text versions within a CLARA project. A generic handler coordinates the workflows for plain, segmented, glossed, lemma-tagged and related versions, routing to the appropriate form and template, enforcing project roles, and invoking CLARAProjectInternal to load, validate and save content. Operations that generate, correct or improve text can be run asynchronously via django_q, with monitor and status endpoints to poll task progress and a completion view to return users to the editing page. Additional views manage acknowledgements and per-project format preferences.",
        "short_summary": "This module provides Django views for creating, annotating and editing different textual representations in a CLARA project. A generic view encapsulates most workflows and delegates to specific forms/templates for each version, invoking CLARAProjectInternal for processing and starting async tasks for AI-based generation. It includes endpoints for polling and displaying asynchronous task status, plus simple views to edit acknowledgements and format preferences.",
        "key_responsibilities": [
          "Dispatch creation and editing of multiple text versions (plain, segmented, glossed, lemma-tagged, etc.) through a common view that loads existing content, validates edits, handles archived versions, and saves updates.",
          "Initiate AI-driven generation, correction or improvement operations and tagging utilities (TreeTagger, Jieba, pypinyin), storing API call metadata and logging project actions.",
          "Expose monitor and status endpoints for asynchronous tasks driven by django_q, and report completion back to the editing interface with user feedback.",
          "Select appropriate forms and templates for each text version and provide role- and credit-based permission checks.",
          "Manage auxiliary project settings such as acknowledgements and format preferences via dedicated forms."
        ],
        "potential_issues": [
          "The imported name `messages` from django.contrib is shadowed by a local variable in generate_text_status, which could be confusing or error-prone.",
          "Exception handling in create_annotated_text_of_right_type raises the caught exception before setting an error message, making the subsequent messages.error unreachable; broad exception catches elsewhere may swallow errors silently.",
          "is_chinese_language is imported twice from different modules, with the second import overwriting the first, which may lead to unexpected behavior if the implementations differ.",
          "Asynchronous task helpers rely on post_task_update messages to convey errors, but unexpected exceptions may not surface in the UI beyond a generic status, and some operations skip credit checks for non-AI paths.",
          "CLARAProjectAction creation is wrapped in a bare except and will silently fail if logging actions cannot be saved."
        ]
      }
    },
    {
      "created_at": "2025-12-23T11:40:44.579436+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 8646,
        "completion_tokens": 1377,
        "total_tokens": 10023,
        "estimated_cost_usd": 0.0245775
      },
      "analysis": {
        "proposed_docstring": "This module defines the Django views used to create, edit, annotate and improve the various text versions within a CLARA project, including plain text, titles, segmentation, glossing, lemmatisation and related variants. It wires up the appropriate forms and templates for each text type, enforces permissions, and invokes synchronous or asynchronous operations (including AI-backed generation, correction and improvement tasks) via the CLARAProjectInternal API, persisting results and logging actions. It exposes endpoints to poll and monitor long-running generation tasks, supports loading archived versions, and handles auxiliary project settings such as acknowledgements and formatting preferences. Long-running tasks are scheduled with django-q and progress is reported back to the client through JSON and dedicated monitor views.",
        "short_summary": "Views for creating and maintaining multiple annotated text versions for CLARA projects. They render the correct form/template per version, handle manual edits, archived loads, and AI- or tagger-driven generation, correction and improvement, often via asynchronous tasks. The module also offers endpoints to monitor task status and views for acknowledgements and format preference configuration.",
        "key_responsibilities": [
          "Render and process forms to create, edit, delete or load archived versions of different text annotations (plain, title, segmented, gloss, lemma, MWE, pinyin, etc.) for a project.",
          "Trigger AI-backed generation, correction and improvement tasks asynchronously using django-q, and persist API call metadata and project actions.",
          "Provide JSON and HTML endpoints to poll and monitor the status of long-running generation/improvement tasks.",
          "Validate and internalise annotated text input, including MWE consistency checks, before saving.",
          "Handle ancillary project settings views such as acknowledgements and format preferences."
        ],
        "potential_issues": [
          "In create_annotated_text_of_right_type, the generic Exception handler re-raises the exception before attempting to add an error message, making the message unreachable and potentially crashing the view.",
          "The local variable name 'messages' in generate_text_status shadows django.contrib.messages and may be confusing; status detection relies on simple substring membership in the updates list without distinguishing running states.",
          "Loading archived files trusts the archived file path from form input; if not validated, this may allow attempts to read unexpected files.",
          "Error handling for asynchronous tasks posts updates but suppresses exceptions, which may make debugging failures harder; task status is limited to 'finished' or 'error' with 'unknown' otherwise.",
          "Multiple imports of is_chinese_language and is_rtl_language from different modules may cause confusion about which implementation is used."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_plain_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_plain_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Plain Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_plain_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_title",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_title' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Text Title",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_title"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_summary",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_summary' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Summary",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_summary"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_cefr_level",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_cefr_level' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Estimate/Edit CEFR Level",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_cefr_level"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_segmented_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_segmented_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Segmented Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_segmented_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_segmented_title",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_segmented_title' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Segmented Title",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_segmented_title"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_translated_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_translated_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Translated Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_translated_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_mwe_tagged_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_mwe_tagged_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit MWE-tagged Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_mwe_tagged_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_phonetic_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_phonetic_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Phonetic Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_phonetic_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_lemma_tagged_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_lemma_tagged_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Lemma Tagged Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_lemma_tagged_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_glossed_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_glossed_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Glossed Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_glossed_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_pinyin_tagged_text",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'create_pinyin_tagged_text' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Create/Edit Pinyin Tagged Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.create_pinyin_tagged_text"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "set_format_preferences",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'set_format_preferences' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Set Format Preferences",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.set_format_preferences"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "edit_acknowledgements",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'edit_acknowledgements' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Acknowledgements",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.annotation_views.edit_acknowledgements"
        }
      ]
    }
  ],
  "clara_app/community_reviewing_views.py": [
    {
      "created_at": "2025-12-22T19:53:56.902010+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2956,
        "completion_tokens": 2341,
        "total_tokens": 5297,
        "estimated_cost_usd": 0.027105
      },
      "analysis": {
        "proposed_docstring": "Views to support community reviewing of coherent images in CLARA projects. Provides entry points for community members, coordinators and external users to browse pages, view alternate images and descriptions, cast votes, hide or request variants, upload images, and leave advice per page. Orchestrates execution of approved community requests via asynchronous django_q tasks, persisting cost information and allowing clients to poll and monitor task status. Relies on CLARAProjectInternal and coherent images utilities to load project data from disk, update AI voting metadata, and promote preferred images, with role-based access enforced by custom decorators.",
        "short_summary": "This module defines Django views that drive the community image review workflow for CLARA projects. It renders page overviews and per-page review screens for different community roles, allowing voting, hiding/unhiding, variant requests, uploads, and advice submission. It also triggers asynchronous execution of approved requests and exposes endpoints to poll and monitor task status.",
        "key_responsibilities": [
          "Render community and coordinator image review pages and per-page review screens based on project story data and alternate images",
          "Process POST actions such as voting on images, hiding/unhiding images, requesting variants, uploading user images, setting request statuses, and adding advice",
          "Trigger asynchronous execution of approved community requests via django_q and store associated cost information",
          "Expose JSON status and monitor views for long-running community request execution tasks"
        ],
        "potential_issues": [
          "Use of asyncio.run within synchronous views may block the server under load",
          "The status detection in execute_community_requests_for_page_status simply searches for substrings 'error' or 'finished' in messages, which may be unreliable",
          "Variable shadowing of the imported messages module in execute_community_requests_for_page_status could be confusing",
          "Assumes story_data indexing by page_number - 1 without validating bounds, which may raise if data is malformed",
          "community_review_images_external is accessible to any logged-in user and calls update_ai_votes_in_feedback for each page, which might be expensive or unintended"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:06:20.820575+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2956,
        "completion_tokens": 1893,
        "total_tokens": 4849,
        "estimated_cost_usd": 0.022625
      },
      "analysis": {
        "proposed_docstring": "Views to support community review and coordination of coherent images in CLARA projects. This module exposes entry points for community members, coordinators, and external users to browse pages, view and vote on alternate images, upload or request variants, and leave advice on a per-page basis. It orchestrates page-level review workflows, updates AI feedback data, and triggers asynchronous execution of approved community requests via django-q. Supporting utilities read project data from the file system, enforce user roles, track task status, and render the appropriate templates.",
        "short_summary": "This module contains Django views for community review of CLARA project images. It allows members and coordinators to overview pages, drill into a page to vote on or hide images, request variants, upload new images, and leave advice. It also exposes an external view of page descriptions and handles kicking off and monitoring asynchronous execution of approved community requests.",
        "key_responsibilities": [
          "Render overview and per-page review pages for community members, coordinators, and external reviewers, pulling story and alternate image data from project files.",
          "Process POST actions on a page (voting, hiding/unhiding images, requesting variants, uploading images, setting request status, adding advice) and persist feedback via helper utilities.",
          "Trigger asynchronous execution of approved community requests using django-q tasks, and provide status/monitoring endpoints for those tasks.",
          "Update AI-derived feedback and promote preferred images in project storage based on community input."
        ],
        "potential_issues": [
          "Use of asyncio.run within synchronous views to load alternate images may block the server under load.",
          "Indexing story_data by page_number - 1 assumes the page_number is valid; no bounds checking could lead to IndexErrors if malformed URLs are hit.",
          "In execute_community_requests_for_page_status, the simplistic `'error' in messages` / `'finished' in messages` check assumes specific strings in task updates and may misclassify status; the local variable shadows the imported messages module.",
          "The upload_image branch expects a FILES key named 'uploaded_image_file_path'; mismatched form fields will silently fail with a generic error.",
          "Preferred image promotion relies on get_page_description_info_for_cm_reviewing returning a valid preferred_image_id; unexpected values could cause unintended promotion."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "community_review_images",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'community_review_images' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Review images as community member",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.community_reviewing_views.community_review_images"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "community_organiser_review_images",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'community_organiser_review_images' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Review images as community organiser",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.community_reviewing_views.community_organiser_review_images"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "community_review_images_external",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'community_review_images_external' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Review images as non-community member",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.community_reviewing_views.community_review_images_external"
        }
      ]
    }
  ],
  "clara_app/community_views.py": [
    {
      "created_at": "2025-12-22T19:54:07.399313+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1985,
        "completion_tokens": 990,
        "total_tokens": 2975,
        "estimated_cost_usd": 0.01238125
      },
      "analysis": {
        "proposed_docstring": "Community-facing Django views for managing communities, membership roles, and project associations within CLARA. Provides admin-only flows to create and delete communities and to promote users to coordinators, coordinator-level functionality to add members to communities they oversee, and project owner controls to assign or clear a community on a project with language validation. Also includes a community home view that displays projects for members. The views are built around the Community, CommunityMembership, and CLARAProject models and render the corresponding templates and forms.",
        "short_summary": "This module defines Django views for community lifecycle and membership management. Admin users can create or delete communities and assign coordinators, coordinators can add members to their communities, and project owners can assign a project to a community with language checks. A community home view shows projects to authorized members.",
        "key_responsibilities": [
          "Handle admin-only creation and deletion of Community records with form workflows and confirmation templates",
          "Render a community home page for members, showing associated projects and user role",
          "Allow admins to promote users to coordinator roles and coordinators to add members via validated forms",
          "Enable project owners to set or clear a project's Community association with validation against project language"
        ],
        "potential_issues": [
          "Role value checks are inconsistent (membership roles are set to 'COORDINATOR'/'MEMBER' but community_home compares to 'CO'), which may break coordinator-specific logic",
          "Assumes userprofile.is_admin exists on all users; missing profiles could raise AttributeError",
          "create_community view lacks feedback on failure/success and uses a hardcoded redirect",
          "Debug print statements in community_home may be undesirable in production and config/logger are defined but unused"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:07:06.846047+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1985,
        "completion_tokens": 2341,
        "total_tokens": 4326,
        "estimated_cost_usd": 0.02589125
      },
      "analysis": {
        "proposed_docstring": "Django view functions for community management in the CLARA app, covering creation, deletion, membership assignment, and project association. It enforces admin or coordinator permissions via login checks, user_passes_test, and custom decorators, uses model-backed forms to gather user and community selections, and renders templates with contextual data and message feedback. Community home access is gated by membership, and project owners can assign or clear a community on their projects with basic validation of language compatibility.",
        "short_summary": "This module defines community-related views such as creating and deleting communities, assigning coordinators and members, and linking projects to communities. It uses login and permission decorators, form handling, and template rendering with Django messages to guide users through these workflows. A community home view requires membership and presents community-specific projects.",
        "key_responsibilities": [
          "Provide admin-only interfaces to create new Community records and manage their deletion with confirmation.",
          "Allow admins to assign coordinator roles and coordinators to assign member roles to users within permitted communities via forms.",
          "Render a community home page that enforces membership and supplies community and project context to templates.",
          "Enable project owners to assign or remove a project's associated community, validating language compatibility before saving."
        ],
        "potential_issues": [
          "Role string comparisons are inconsistent (e.g. using 'COORDINATOR' when assigning roles but checking for 'CO' in community_home), which may prevent coordinator-specific logic from running.",
          "create_community redirects without flashing a success or error message, which may leave users without feedback on the operation.",
          "Community deletion is performed directly and may not account for related objects or cascade effects; additional checks or safeguards might be needed.",
          "community_home includes a print statement for debugging that could clutter logs and exposes the role value.",
          "Project-community assignment relies on manual conversion of community IDs from strings and catches only ValueError/ValidationError; unexpected data could still cause errors or may need clearer user feedback."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "assign_member_to_community",
          "args_raw": [],
          "href_expr": "{% url 'assign_member_to_community' %}",
          "element": "a",
          "attr": "href",
          "title": "Add a new member to a community for which you are coordinator.",
          "text": "Add member to community",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.community_views.assign_member_to_community"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_community",
          "args_raw": [],
          "href_expr": "{% url 'create_community' %}",
          "element": "a",
          "attr": "href",
          "title": "Create a new community for image reviewing and similar activities.",
          "text": "Create community",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.community_views.create_community"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "delete_community_menu",
          "args_raw": [],
          "href_expr": "{% url 'delete_community_menu' %}",
          "element": "a",
          "attr": "href",
          "title": "Delete an existing community.",
          "text": "Delete community",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.community_views.delete_community_menu"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "assign_coordinator_to_community",
          "args_raw": [],
          "href_expr": "{% url 'assign_coordinator_to_community' %}",
          "element": "a",
          "attr": "href",
          "title": "Assign a coordinator to an language community.",
          "text": "Assign coordinator to community",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.community_views.assign_coordinator_to_community"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "project_community",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'project_community' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Community",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.community_views.project_community"
        }
      ]
    }
  ],
  "clara_app/comparing_views.py": [
    {
      "created_at": "2025-12-22T19:54:19.260850+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1146,
        "completion_tokens": 1237,
        "total_tokens": 2383,
        "estimated_cost_usd": 0.0138025
      },
      "analysis": {
        "proposed_docstring": "Django views for retrieving version-specific metadata and comparing editions of CLARA project texts. Authenticated users with a project role can fetch metadata for a given version as JSON or post selections to compute and render a diff between two files within a version. The module dynamically populates a diff selection form from project metadata, delegates diff computation to CLARAProjectInternal, and prepares results for rendering with appropriate markup. It also injects user configuration such as the CLARA version into templates and handles internalisation errors via the messages framework.",
        "short_summary": "This module defines views that let authorized users access metadata for specific versions of a CLARA project and compare two editions of a text. It builds and populates a diff selection form from project metadata, calls into CLARAProjectInternal to compute differences, and renders the results alongside the form. Errors during diff computation are surfaced via Django messages and some markup is converted to HTML spans for display.",
        "key_responsibilities": [
          "Fetch and return metadata for a specific project version as JSON to authenticated, authorized users.",
          "Render and process a diff selection form for comparing two files within a project version.",
          "Invoke CLARAProjectInternal to retrieve metadata and compute diffs between text editions.",
          "Prepare diff output for display by converting custom markup to HTML and rendering appropriate templates with project context and user configuration."
        ],
        "potential_issues": [
          "Form validation is commented out, and values are taken directly from request.POST, which may lead to KeyError or bypass validation.",
          "Dynamic assignment of form choices without validation may allow invalid selections or make the form's is_valid() unusable.",
          "Version and file inputs are not validated against available metadata, so invalid or tampered POST data could trigger errors in diff computation.",
          "The module initializes a global config but does not use it within these views; ensure this is intentional or remove unused code."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:07:32.097624+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1146,
        "completion_tokens": 1116,
        "total_tokens": 2262,
        "estimated_cost_usd": 0.0125925
      },
      "analysis": {
        "proposed_docstring": "View handlers for comparing different versions of CLARA project texts and exposing version metadata. This module provides a JSON endpoint to fetch file metadata for a given project version and a form-driven page to select two files and compute a diff between them using CLARAProjectInternal. Form choices are populated dynamically from project metadata, diff markup is converted to HTML, and errors are reported through Django's messages framework.",
        "short_summary": "This module defines Django views to support comparing file versions within a CLARA project. It exposes a JSON API to retrieve metadata for a specific version and a form-based interface that lets logged-in users select files, compute diffs, and render the results. The views rely on CLARAProjectInternal for metadata and diffing and dynamically adjust form choices based on available metadata.",
        "key_responsibilities": [
          "Fetch and return project file metadata for a specified version as JSON to authenticated users with project roles.",
          "Render and process a form for selecting two files and a version to compute a textual diff via CLARAProjectInternal.",
          "Populate form choices dynamically from project metadata and render diff results with basic markup-to-HTML conversion.",
          "Handle internalisation errors by surfacing messages and re-rendering the selection form."
        ],
        "potential_issues": [
          "Form validation is bypassed and request.POST is accessed directly; malformed or missing POST data may cause errors or bypass expected validation.",
          "Dynamic population of form choices could be why form validation fails; choices are set after instantiation and may not match posted values.",
          "The template context on POST does not include clara_version, which may be expected by the template and could cause rendering issues.",
          "Unused configuration and logger imports suggest missing logging; errors in diff conversion are not logged and could be hard to trace.",
          "No handling if requested version or files are absent from metadata; CLARAProjectInternal.diff_editions_of_text_version may raise or fail silently."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "compare_versions",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'compare_versions' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Compare Text Versions",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.comparing_views.compare_versions"
        }
      ]
    }
  ],
  "clara_app/content_password_views.py": [
    {
      "created_at": "2025-12-22T19:54:33.258313+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1000,
        "completion_tokens": 1020,
        "total_tokens": 2020,
        "estimated_cost_usd": 0.01145
      },
      "analysis": {
        "proposed_docstring": "Views for listing and managing password protection on content within CLARA projects. Provides a dashboard of protected content owned by the logged-in user along with per-item forms to update or clear passwords and hints. Ensures only the project owner can make changes via a simple ownership assertion, and uses Django messages and templates to render feedback. Interacts with the Content model, CLARAProject model, and ContentPasswordUpdateForm to persist password hashes and hints.",
        "short_summary": "This module contains Django views to list content items with passwords and allow a logged-in project owner to set or clear those passwords. It renders a management page with forms per protected content and processes POST submissions to update or remove protection, providing user feedback via messages.",
        "key_responsibilities": [
          "Render a management page of password-protected Content objects for projects owned by the current user with prepopulated update forms.",
          "Handle POST submissions to clear a content item's password after verifying project ownership.",
          "Handle POST submissions to set or update a content item's password and hint, treating empty input as a request to clear protection.",
          "Enforce that only the owning user can modify content protection via an ownership assertion."
        ],
        "potential_issues": [
          "The ownership assertion is very strict (only the exact project owner), which may exclude other roles; a comment notes this could be relaxed.",
          "POST-only behavior is enforced via method checks and redirects rather than decorators like require_POST, so non-POST requests silently redirect.",
          "The type annotation for _assert_owner expects a CLARAProjectInternal but it is called with the model instance; this may be misleading.",
          "Excluded content selection only checks for password_hash being non-null; content with empty strings or other states might be skipped or included unintentionally."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:08:32.337755+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1000,
        "completion_tokens": 1452,
        "total_tokens": 2452,
        "estimated_cost_usd": 0.01577
      },
      "analysis": {
        "proposed_docstring": "Views for managing password protection on Content objects owned by a user. Provides an owner check helper and three entry points: a listing page of protected content with per-row update forms, and POST handlers to set/change or clear a password and hint. Interacts with the Content and CLARAProject models, a ContentPasswordUpdateForm, and uses Django messages and templates to render feedback and redirect to the management page.",
        "short_summary": "This module implements Django views to list and update passwords on content tied to projects the current user owns. It renders a management page showing protected content and per-item forms, and provides POST handlers to set/change or clear a content password. Access is enforced via an owner assertion and feedback is communicated through Django's messages framework.",
        "key_responsibilities": [
          "Filter and render password-protected Content items for projects owned by the requesting user.",
          "Instantiate and pass ContentPasswordUpdateForm instances to the management template for each item.",
          "Handle POST requests to clear an existing content password after asserting ownership.",
          "Handle POST requests to set or change a content password and hint, treating empty input as a clear operation and persisting changes with appropriate success messages."
        ],
        "potential_issues": [
          "Protected content filtering excludes only NULL password hashes; records with empty strings may still appear unexpectedly.",
          "The type hint on `_assert_owner` suggests `CLARAProjectInternal` but is passed a `Content.project`, which could be confusing if types diverge.",
          "Unused import of `timezone` and commented out rate limiting hints at missing brute-force protection or incomplete cleanup.",
          "Only project owners are allowed; if other roles should manage passwords this check would need adjustment."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "manage_content_passwords",
          "args_raw": [],
          "href_expr": "{% url 'manage_content_passwords' %}",
          "element": "a",
          "attr": "href",
          "title": "Change or remove passwords on content where you have set them.",
          "text": "Change/remove content passwords",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.content_password_views.manage_content_passwords"
        }
      ]
    }
  ],
  "clara_app/content_views.py": [
    {
      "created_at": "2025-12-22T19:55:02.163934+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4828,
        "completion_tokens": 2582,
        "total_tokens": 7410,
        "estimated_cost_usd": 0.031855
      },
      "analysis": {
        "proposed_docstring": "Views for registering, listing and viewing CLARA content, handling both internal project-derived texts and externally registered URLs. It exposes entry points for offering to register rendered project output, registering content (with optional protection), and rendering detail pages where users can unlock, rate, comment, delete and build downloadable zip archives. Public counterparts list and show content with manifest generation, access counting and simple unlock token handling. Additional utilities include email notification on ratings/comments and aggregate language statistics across projects and content.",
        "short_summary": "This module implements the user-facing and public views around CLARA content. It lets project owners register rendered texts as content, handles external content registration, and lists/searches available items. Detail views support unlocking protected content, ratings, comments, download zip building and email notifications, with public equivalents that gate access via signed tokens. It also provides aggregate statistics by language.",
        "key_responsibilities": [
          "Offer and perform registration of rendered project content (normal or phonetic) and external content sources, including optional password protection.",
          "List and search content for logged-in and public users with ordering and pagination.",
          "Render content detail pages for authenticated and public users, handling unlock flow, access counting, ratings, comments, deletion and manifest retrieval.",
          "Send notification emails to content owners/co-owners on new ratings or comments and expose language-level statistics summaries.",
          "Trigger building of downloadable content zip archives and provide programmatic access tokens for protected content."
        ],
        "potential_issues": [
          "In content_detail the unlock logic references an undefined variable 'form' and never instantiates an unlock form on GET, so protected content may not be unlockable and may raise NameError on POST.",
          "build_content_zip lacks any authentication/authorization decorators, allowing unauthenticated users to trigger zip builds for project content.",
          "Deletion permission in content_detail only checks project.user or admin and may ignore other owner roles defined via project permissions.",
          "Access counting simply increments on each view after unlock and is not truly unique; there is no throttling on authenticated unlock attempts (the rate limit is commented out).",
          "Public content list/detail expose all Content objects without filtering by protection status, potentially leaking metadata for protected items."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:09:24.585059+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4828,
        "completion_tokens": 2100,
        "total_tokens": 6928,
        "estimated_cost_usd": 0.027034999999999997
      },
      "analysis": {
        "proposed_docstring": "Views for managing C-LARA content: registering rendered project texts or external URLs, listing and filtering available content, and displaying detail pages with ratings, comments and optional password protection. Provides both authenticated and public-facing variants of content lists and detail views, including unlock handling, access counting, email notifications and zip-file generation. Also exposes language-level statistics and simple throttling of password attempts via cache.",
        "short_summary": "This module defines Django views for registering, listing and viewing content in the C-LARA application. It handles project-based and external content registration, search and sort of content lists, and detail pages with ratings, comments, zip downloads and password protection. Public-facing counterparts expose similar functionality with unlock tokens and manifests, and language statistics are computed for reporting.",
        "key_responsibilities": [
          "Offer and process registration of rendered project content or external content via forms, with optional password protection and update feed entries.",
          "Render authenticated and public content lists with search filters, ordering and pagination.",
          "Display content detail pages, handling protected unlock flows, access counting, ratings, comments, deletion, zip availability and notification emails.",
          "Serve public detail pages with manifest retrieval, unlock token signing and throttled password attempts, and trigger zip build for project content.",
          "Aggregate and render per-language statistics on projects and content."
        ],
        "potential_issues": [
          "PermissionDenied is raised in register_project_content but not imported, which will cause a NameError when triggered.",
          "In content_detail the unlock POST branch checks form.is_valid() instead of the instantiated unlock_form, which will raise a NameError and bypass password validation.",
          "build_content_zip is not decorated with login_required or permission checks, allowing unauthenticated users to trigger zip creation for project content.",
          "content_success calls get_user_config on request.user without a login requirement; if accessed by an anonymous user it may error.",
          "Password attempt throttling (too_many_attempts) is commented out in content_detail, so authenticated users can brute-force protected content without rate limiting."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "content_list",
          "args_raw": [],
          "href_expr": "{% url 'content_list' %}",
          "element": "a",
          "attr": "href",
          "title": "List all the content that has been registered in the C-LARA social network.",
          "text": "Published content",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.content_views.content_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "public_content_list",
          "args_raw": [],
          "href_expr": "{% url 'public_content_list' %}",
          "element": "a",
          "attr": "href",
          "title": "Browse C-LARA and LARA content without logging in.",
          "text": "Published content (external view)",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.content_views.public_content_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "language_statistics",
          "args_raw": [],
          "href_expr": "{% url 'language_statistics' %}",
          "element": "a",
          "attr": "href",
          "title": "Show tables listing numbers of projects and pieces of content, broken down by language.",
          "text": "Project and content statistics",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.content_views.language_statistics"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "register_content",
          "args_raw": [],
          "href_expr": "{% url 'register_content' %}",
          "element": "a",
          "attr": "href",
          "title": "Register a piece of LARA content to make it accessible through the C-LARA social network.",
          "text": "Register external LARA content",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.content_views.register_content"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "public_content_list",
          "args_raw": [],
          "href_expr": "{% url 'public_content_list' %}",
          "element": "a",
          "attr": "href",
          "title": "Browse C-LARA and LARA content without logging in.",
          "text": "Content",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.content_views.public_content_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "offer_to_register_content_normal",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'offer_to_register_content_normal' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Register Rendered Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.content_views.offer_to_register_content_normal"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "offer_to_register_content_phonetic",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'offer_to_register_content_phonetic' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Register Rendered Phonetic Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.content_views.offer_to_register_content_phonetic"
        }
      ]
    }
  ],
  "clara_app/create_project_views.py": [
    {
      "created_at": "2025-12-22T19:55:16.634697+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3471,
        "completion_tokens": 1642,
        "total_tokens": 5113,
        "estimated_cost_usd": 0.02075875
      },
      "analysis": {
        "proposed_docstring": "This module defines views and helpers around creating, importing, monitoring, and cloning C-LARA projects. It handles simple creation via form submission, import of a project from a zip archive via an asynchronous django-q task with status polling, and cloning an existing project including copying internal files. It coordinates between Django models, the C-LARA internal project representation, various utility functions for file handling and S3, and renders the appropriate templates with user-specific configuration.",
        "short_summary": "Provides Django views for creating new projects, importing projects from zipfiles asynchronously with status monitoring, and cloning existing projects. It wires form handling to model creation, kicks off background tasks for long-running imports, updates project metadata, and renders templates for creation and monitoring.",
        "key_responsibilities": [
          "Render and process project creation forms, instantiating CLARAProject records and corresponding internal project objects.",
          "Accept and stage uploaded project zipfiles, schedule asynchronous import tasks, and update project metadata and audio info from extracted content.",
          "Expose JSON endpoints and monitoring pages for tracking async import progress and handling completion redirects.",
          "Clone existing projects by creating new records and copying internal project files to a new internal ID."
        ],
        "potential_issues": [
          "In clone_project, the new CLARAProject is instantiated but not saved before using its id to generate an internal_id, so new_project.id will be None unless saved first.",
          "The async import worker uses get_object_or_404 in a non-view context, which raises Http404; the exception is caught, but using a model query might be clearer.",
          "import_project_status checks for literal 'error' or 'finished' strings in the list of messages; if messages are not exact matches, status detection may be unreliable.",
          "Variable name 'messages' in import_project_status shadows the imported django.contrib.messages, which could be confusing.",
          "Using placeholder l1 and l2 values when creating a project before import completion may expose inconsistent data if accessed prematurely."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:10:14.409079+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3471,
        "completion_tokens": 2701,
        "total_tokens": 6172,
        "estimated_cost_usd": 0.03134875
      },
      "analysis": {
        "proposed_docstring": "Django views for creating, importing, monitoring, and cloning C-LARA projects. This module handles user-facing forms to set up new projects, kicks off asynchronous imports of exported project zip files and reconstructs their internal representation and metadata, and exposes polling endpoints and templates to monitor background tasks. It also provides a cloning workflow that duplicates an existing project and copies its internal assets, integrating with CLARAProjectInternal, audio metadata models, and various file-handling utilities.",
        "short_summary": "This module defines the views for creating a C-LARA project, importing one from a zip export via a django_q background task, and cloning an existing project. It orchestrates creation of CLARAProject and CLARAProjectInternal records, updates metadata such as audio settings from imported files, and provides JSON endpoints and pages to monitor import status. File handling utilities manage temporary storage and S3 transfers when needed.",
        "key_responsibilities": [
          "Render and process project creation forms, validating mutually exclusive options and initializing CLARAProject and CLARAProjectInternal instances.",
          "Handle project import requests by saving uploaded zip files, scheduling asynchronous reconstruction of internal projects from exports, and updating project metadata and audio info.",
          "Expose status and monitoring views that return task updates as JSON or render polling templates for long-running imports.",
          "Implement project cloning by creating a new project with copied metadata and copying internal assets from an existing CLARAProjectInternal."
        ],
        "potential_issues": [
          "In the clone_project workflow, the internal ID is generated before the new project is saved, so the primary key may be None when computing the ID.",
          "import_project_from_zip_file posts an error if internal project creation fails but does not return early, potentially leading to attribute access on None and exceptions.",
          "Imported projects are initially created with placeholder languages; if the import fails the project may remain with incorrect l1/l2 values.",
          "File cleanup via remove_file runs in all cases and may delete the uploaded zip from S3/local storage even if retries are desired.",
          "Mutually exclusive coherent image set flags are checked on creation but not when importing or cloning, so inconsistent combinations might slip through."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "create_project",
          "args_raw": [],
          "href_expr": "{% url 'create_project' %}",
          "element": "a",
          "attr": "href",
          "title": "Create a new C-LARA project, specifying the title, the text language, and the annotation language.",
          "text": "Create new C-LARA project using Advanced C-LARA",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.create_project_views.create_project"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "import_project",
          "args_raw": [],
          "href_expr": "{% url 'import_project' %}",
          "element": "a",
          "attr": "href",
          "title": "Import a project from a zipfile created using the 'Export zipfile' command.",
          "text": "Import C-LARA project from zipfile",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.create_project_views.import_project"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "clone_project",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'clone_project' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Clone Project",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.create_project_views.clone_project"
        }
      ]
    }
  ],
  "clara_app/credit_views.py": [
    {
      "created_at": "2025-12-22T19:55:37.299278+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1266,
        "completion_tokens": 1474,
        "total_tokens": 2740,
        "estimated_cost_usd": 0.0163225
      },
      "analysis": {
        "proposed_docstring": "Views for managing user credit balances within the CLARA application, including displaying balances, allowing administrators to add credit, and enabling users to transfer credit to others. The module wires up form handling, basic permission checks, session-backed transfer confirmation, and notification via email, rendering corresponding templates with contextual settings such as the user's CLARA version.",
        "short_summary": "This module implements Django views to view and adjust user credit balances. Logged-in users can see their own credit, administrators can add credit to accounts, and users can initiate transfers to other accounts with a confirmation code sent via email. Pending transfers are stored in the session and finalized upon code verification.",
        "key_responsibilities": [
          "Render the current user's credit balance along with CLARA version metadata.",
          "Provide an admin-only endpoint to add credit to a specified user's profile via AddCreditForm.",
          "Handle credit transfers by collecting recipient and amount, checking balances, sending confirmation codes via email, and staging transfer details in the session.",
          "Verify confirmation codes with ConfirmTransferForm to complete staged transfers and update user profiles accordingly."
        ],
        "potential_issues": [
          "The transfer confirmation error branch renders a template without the 'clara_app/' prefix, which may not exist.",
          "Transfer credit uses AddCreditForm and treats the 'user' field as a username string; if the form is a ModelChoiceField it may not match expectations.",
          "No transactional safeguards are used when debiting/crediting balances, so concurrent requests could lead to race conditions or overdrafts between staging and confirmation.",
          "Pending transfer details are stored in the session without expiry or signature, and available credit is not revalidated at confirmation time.",
          "Email obfuscation assumes addresses are at least 10 characters and may behave oddly with very short email addresses."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:10:42.407795+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1266,
        "completion_tokens": 1575,
        "total_tokens": 2841,
        "estimated_cost_usd": 0.0173325
      },
      "analysis": {
        "proposed_docstring": "Views for managing the C-LARA credit system, providing balance display, admin credit additions, and user-to-user transfers with confirmation. Forms and Django messages are used to collect and validate input, update user profile credit fields, and render templates with configuration such as the current Clara version. Pending transfers are stored in the session and finalized only after the user enters a confirmation code received by email.",
        "short_summary": "This module defines Django views for displaying and manipulating user credit balances. It supports administrators adding credit to accounts and logged-in users transferring credit to others. Transfers are staged in the session and require a confirmation code sent via email before balances are updated, with templates rendered including Clara version context.",
        "key_responsibilities": [
          "Display the logged-in user's current credit balance alongside the Clara version.",
          "Allow admin users to add credit to any user's profile via an AddCreditForm.",
          "Handle initiation of credit transfers by validating recipients and funds, storing pending transfer details in the session, and emailing a confirmation code.",
          "Confirm pending transfers by validating a submitted code, adjusting sender and recipient credits, and providing user feedback via messages."
        ],
        "potential_issues": [
          "Inconsistent handling of the AddCreditForm's 'user' field: in one view it's treated as a User instance, in another as a username string, which may lead to lookup errors.",
          "Some error render paths omit the 'clara_version' context or use a different template path (e.g. 'confirm_transfer.html' vs 'clara_app/confirm_transfer.html'), which could break templates.",
          "No validation against transferring negative amounts or transferring to oneself, and no recheck of available balance at confirmation time.",
          "Email anonymization assumes a minimum length and may fail or produce odd results for short email addresses; sending confirmation uses the sender's email, which might be empty or invalid.",
          "Session-based staging of transfers lacks expiry handling and could be susceptible to concurrent balance changes before confirmation."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "add_credit",
          "args_raw": [],
          "href_expr": "{% url 'add_credit' %}",
          "element": "a",
          "attr": "href",
          "title": "Add credit to a user's GPT-4 call account",
          "text": "Add credit to user",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.credit_views.add_credit"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "credit_balance",
          "args_raw": [],
          "href_expr": "{% url 'credit_balance' %}",
          "element": "a",
          "attr": "href",
          "title": "C-LARA is free, except that calls to GPT-4 cost money. Show how much you have left on your account.",
          "text": "Credit balance for ChatGPT-4 API calls",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.credit_views.credit_balance"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "transfer_credit",
          "args_raw": [],
          "href_expr": "{% url 'transfer_credit' %}",
          "element": "a",
          "attr": "href",
          "title": "Transfer some of the credit from your GPT-4 call account to another user.",
          "text": "Transfer credit to another user",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.credit_views.transfer_credit"
        }
      ]
    }
  ],
  "clara_app/delete_tts_views.py": [
    {
      "created_at": "2025-12-22T19:56:01.153371+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1110,
        "completion_tokens": 1601,
        "total_tokens": 2711,
        "estimated_cost_usd": 0.0173975
      },
      "analysis": {
        "proposed_docstring": "Admin-only Django views that orchestrate deletion of cached text-to-speech data for a selected language. Provides a form-driven entry point to launch the cleanup, schedules the actual deletion as a django-q asynchronous task, and supplies templates and a JSON API for monitoring progress and reporting completion. Integrates with AudioAnnotator for the deletion logic and utility helpers to attach task callbacks and user configuration metadata to the UI.",
        "short_summary": "This module defines the views for deleting cached TTS data per language, restricted to administrators. It presents a form to start the deletion, kicks off the deletion asynchronously via django-q, and redirects to a monitoring page. An API endpoint returns task updates for polling, and a completion view displays success or error messages and allows re-running the deletion.",
        "key_responsibilities": [
          "Render and handle the DeleteTTSDataForm to initiate TTS data deletion for a chosen language",
          "Schedule the deletion work as an asynchronous task using django_q with callback/report tracking",
          "Provide a JSON status endpoint that returns task update messages for client-side polling",
          "Render monitoring and completion templates, surfacing clara version and success/error feedback to admins"
        ],
        "potential_issues": [
          "Assumes every authenticated user has a userprofile with an is_admin attribute; missing profiles will raise errors",
          "Async task error handling is minimal; failures inside the task may not be surfaced clearly beyond generic status checks",
          "Status detection checks for literal 'error' or 'finished' in messages, which may not align with the structure of updates returned by get_task_updates",
          "The monitor view does not perform any status logic itself and relies on client-side polling with potentially naive status values",
          "Repeated printing to stdout instead of using the configured logger could hinder production diagnostics"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:11:17.563654+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1110,
        "completion_tokens": 985,
        "total_tokens": 2095,
        "estimated_cost_usd": 0.0112375
      },
      "analysis": {
        "proposed_docstring": "This module provides admin-only Django views to initiate, monitor, and report completion of asynchronous deletion of cached text-to-speech data for a given language. It wraps an AudioAnnotator helper to perform the deletion and uses django_q to run the task in the background, wiring up callback/report IDs so progress can be polled via a JSON status endpoint. The views render forms for selecting a language, redirect to a monitor page during execution, and surface success/error messages upon completion.",
        "short_summary": "Exposes views for administrators to delete cached TTS data for a selected language using an asynchronous background task. It sets up callback tracking for task updates, provides a monitor page and JSON polling endpoint, and reports completion status back to the user via Django messages and templates.",
        "key_responsibilities": [
          "Handle form submission to select a language and trigger asynchronous deletion of TTS data via django_q tasks.",
          "Create and pass callback/report identifiers to collect task progress updates and redirect users to a monitoring view.",
          "Expose a JSON endpoint that returns task update messages and a coarse status for client-side polling.",
          "Render monitoring and completion views, including user feedback through Django's messaging framework."
        ],
        "potential_issues": [
          "The variable name `messages` in `delete_tts_data_status` shadows the imported Django messages API, which could be confusing and may lead to mistakes if modified.",
          "Status detection in `delete_tts_data_status` checks for string membership in the messages list; if updates are structured differently, status may remain 'unknown'.",
          "There is limited error handling around the asynchronous task invocation; failures in `async_task` or `delete_tts_data_for_language` are not caught or surfaced beyond callback messages.",
          "The monitor view itself does not fetch or display status; it relies on client-side polling hitting the status endpoint, which must be implemented in templates/JavaScript."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "delete_tts_data",
          "args_raw": [],
          "href_expr": "{% url 'delete_tts_data' %}",
          "element": "a",
          "attr": "href",
          "title": "Remove all cached TTS data for a given language.",
          "text": "Delete TTS data",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.delete_tts_views.delete_tts_data"
        }
      ]
    }
  ],
  "clara_app/funding_requests_views.py": [
    {
      "created_at": "2025-12-22T19:56:29.468295+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1975,
        "completion_tokens": 2176,
        "total_tokens": 4151,
        "estimated_cost_usd": 0.02422875
      },
      "analysis": {
        "proposed_docstring": "Views for handling the C-LARA funding request workflow, including submission by users and review/approval by designated funding reviewers. Provides endpoints to create funding requests, filter and approve them via a formset, trigger email confirmation with a code, and finalize approvals by updating request records and transferring user credits. Integrates with FundingRequest forms and templates, uses session storage for pending approvals, and sends notification emails via the utility mail helper.",
        "short_summary": "This module defines Django views that implement the funding request lifecycle. Authenticated users can submit funding requests, while funding reviewers can search, approve, and finalize transfer of credits. The approval process uses a two-step confirmation with an emailed code and updates FundingRequest records, user profiles, and notifies requesters.",
        "key_responsibilities": [
          "Render and process the funding request submission form for logged-in users.",
          "Provide a review interface for funding reviewers to search funding requests and prepare approval/credit assignments via a formset.",
          "Initiate confirmation by emailing a code and storing pending transfers in the session when approvals are staged.",
          "Confirm approvals by validating the confirmation code, updating FundingRequest status and assigned credits, transferring user profile credits, and sending notifications."
        ],
        "potential_issues": [
          "credit_assigned values are cast to int during review, potentially losing decimal precision if fractional amounts are allowed.",
          "Status comparisons (e.g., checking for 'Submitted') may not align with the labels passed into the formset, depending on how choices are defined in the form.",
          "Available credit is only checked at the staging step; user balances are not revalidated when confirming, and concurrent changes could lead to overdrawing.",
          "Credit transfers and request updates are performed without transactional safeguards, so concurrent approvals could lead to inconsistent balances."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:13:16.187153+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1975,
        "completion_tokens": 1411,
        "total_tokens": 3386,
        "estimated_cost_usd": 0.01657875
      },
      "analysis": {
        "proposed_docstring": "Views to handle the C-LARA funding workflow: allowing authenticated users to submit funding requests, enabling designated reviewers to search, review and approve requests, and confirming approvals with a emailed confirmation code before transferring credits. Reviewers can filter requests, allocate funds via a formset, and the module orchestrates email notifications and session storage of pending transfers, updating FundingRequest records and user balances upon confirmation.",
        "short_summary": "This module defines Django views for creating and processing funding requests within the C-LARA application. Authenticated users can submit new requests, while reviewers can filter and approve them, triggering an email confirmation step. Upon confirmation, the code updates request statuses, transfers credits between user profiles, and notifies requesters via email.",
        "key_responsibilities": [
          "Render and process the funding request submission form for logged-in users",
          "Allow reviewers to filter funding requests and allocate credits via an approval formset",
          "Send confirmation emails to reviewers and handle confirmation code input to finalize approvals",
          "Update FundingRequest records, adjust user profile credit balances, and notify requesters of approvals"
        ],
        "potential_issues": [
          "Credit balance checks and transfers are not wrapped in a transaction and may be subject to race conditions or mid-process balance changes.",
          "Approval processing relies on form POST data without re-querying or validating the current status of each FundingRequest, which could allow tampering or approving already-processed requests.",
          "Credit assignments are cast to int, potentially dropping cents and causing rounding errors when dealing with Decimal fields.",
          "Initial formset status uses display labels from choices; if the ApproveFundingRequestFormSet expects raw status values, there may be mismatches between displayed and processed statuses.",
          "Email anonymization logic assumes email length and may produce odd results for short addresses."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "funding_request",
          "args_raw": [],
          "href_expr": "{% url 'funding_request' %}",
          "element": "a",
          "attr": "href",
          "title": "Submit a request to get a small amount of OpenAI credit",
          "text": "Funding request",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.funding_requests_views.funding_request"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "review_funding_requests",
          "args_raw": [],
          "href_expr": "{% url 'review_funding_requests' %}",
          "element": "a",
          "attr": "href",
          "title": "Review funding requests",
          "text": "Review funding requests",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.funding_requests_views.review_funding_requests"
        }
      ]
    }
  ],
  "clara_app/home_views.py": [
    {
      "created_at": "2025-12-22T19:56:40.341486+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 808,
        "completion_tokens": 1180,
        "total_tokens": 1988,
        "estimated_cost_usd": 0.012810000000000002
      },
      "analysis": {
        "proposed_docstring": "Views for handling the C-LARA landing flow, including redirecting users to login or appropriate home pages based on community membership, presenting a community-selection screen when needed, and rendering the main home page with recent content and activity. It wires up the UnifiedSearchForm to control the time window for displayed items, fetches Content and Activity instances accordingly, and annotates activities for custom status ordering. Utility functions provide redirects and ordering helpers for use in templates.",
        "short_summary": "This module defines the entry points for the application's home and welcome pages. It redirects users to login or the correct home depending on their community memberships, shows a selection page when multiple communities exist, and renders the main C-LARA home page with recent content and activities filtered by a time period. Activities are annotated to enforce a custom sort order by status before being passed to templates.",
        "key_responsibilities": [
          "Redirect unauthenticated or ambiguous landing requests to login or the appropriate home view.",
          "Determine a user's community memberships to route them to a specific community home or present a selection page.",
          "Render the login-protected C-LARA home page with recent Content and Activity filtered by a configurable time period from UnifiedSearchForm.",
          "Annotate and order Activity querysets by a custom status priority before display."
        ],
        "potential_issues": [
          "The module imports configuration via get_config but never uses it, which may indicate dead code.",
          "home_page is not login-protected; anonymous users with no memberships will be redirected to clara_home_page, which requires login and may cause an unexpected redirect loop.",
          "time_period from GET is cast directly to int without validation beyond form cleaning; invalid or negative values could raise errors or produce odd results.",
          "Community membership checks use multiple queries (exists and count); this could be optimized, and status strings in annotate_and_order_activities_for_home_page must match model choices to avoid default ordering."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:13:40.683079+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 808,
        "completion_tokens": 955,
        "total_tokens": 1763,
        "estimated_cost_usd": 0.01056
      },
      "analysis": {
        "proposed_docstring": "Views for directing users to appropriate C-LARA landing pages, determining whether to show a generic home, a community-specific home, or a selection screen based on their memberships. Provides the main home page rendering recent content and activities filtered by a configurable time period, with support for a unified search form. Includes helper logic to annotate and order activities for display and simple redirects for login and default home access.",
        "short_summary": "This module defines the home and landing page views for the C-LARA application. It routes users to community-specific pages or a general home based on their memberships and authentication status. It renders the main home page with recent contents and activities filtered by a selectable time period, and orders activities by status for display.",
        "key_responsibilities": [
          "Redirect unauthenticated or generic home requests to appropriate login or home URLs.",
          "Determine and route users to community homes, the generic C-LARA home, or a selection page based on community memberships.",
          "Render the main C-LARA home page with recent content and activities filtered by a time period from a search form.",
          "Annotate and order activity querysets by status and creation date for presentation."
        ],
        "potential_issues": [
          "The general home/home_page views are not decorated with login_required, so anonymous users may hit them and produce unexpected redirects or behavior.",
          "Community membership checks in home_page perform separate queries (exists/count/first), which may be inefficient; using count could produce extra database hits.",
          "The get_config() call assigns to config but is unused in this module, indicating possible leftover or missing configuration usage.",
          "The time_period conversion in clara_home_page assumes form validation ensures an integer; malformed GET parameters could still cause errors if validation is bypassed."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "home_page",
          "args_raw": [],
          "href_expr": "{% url 'home_page' %}",
          "element": "a",
          "attr": "href",
          "title": "Home page: show recent activities and content",
          "text": null,
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.home_views.home_page"
        }
      ]
    }
  ],
  "clara_app/human_audio_views.py": [
    {
      "created_at": "2025-12-22T19:57:00.283705+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 6799,
        "completion_tokens": 1874,
        "total_tokens": 8673,
        "estimated_cost_usd": 0.02723875
      },
      "analysis": {
        "proposed_docstring": "Views for configuring, uploading, and processing human (and phonetic) audio assets for CLARA projects. This module renders forms to capture audio metadata, accepts individual file uploads or LiteDevTools zip packages, and triggers asynchronous tasks to unpack, align, and install audio via CLARAProjectInternal and AudioRepositoryORM. It also exposes polling endpoints and monitoring pages for background tasks, and download endpoints for generated metadata and annotated text files.",
        "short_summary": "This module contains Django views to manage human voice recordings and related metadata for CLARA projects. It supports both standard and phonetic audio workflows, including individual uploads, LiteDevTools zip imports, and manual text/audio alignment. Background processing is delegated to django-q async tasks with accompanying status and monitoring views, and helper endpoints generate metadata and labelled text for download.",
        "key_responsibilities": [
          "Render and handle forms for human and phonetic audio configuration, including labelled segmented text and audio item formsets",
          "Process individual audio uploads, LiteDevTools zip archives, and manual alignment audio/metadata files, saving to AudioRepositoryORM and triggering CLARAProjectInternal methods",
          "Initiate and monitor asynchronous tasks for zipfile processing and manual alignment via django-q, providing JSON status endpoints and monitoring templates",
          "Generate downloadable metadata and labelled segmented text files for voice recorder and manual alignment workflows"
        ],
        "potential_issues": [
          "Phonetic audio processing view bypasses form.is_valid validation and manually parses POST, which may hide form errors or accept invalid data",
          "Manual alignment branch uses messages.success when required inputs are missing, which may mislead users about an error state",
          "Restoring existing files on POST in human_audio_processing relies on request.FILES keys; inadvertent overwrites or missing file handling could occur",
          "Use of file_exists/local_file_exists with S3/local copies may be brittle if storage state is inconsistent, and remove_file in async tasks will delete the uploaded archive after processing"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:14:58.342687+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 6799,
        "completion_tokens": 2469,
        "total_tokens": 9268,
        "estimated_cost_usd": 0.033188749999999996
      },
      "analysis": {
        "proposed_docstring": "Views for managing human voice audio in CLARA projects. This module exposes forms to upload or record audio clips, trigger manual text/audio alignment, and handle phonetic and non-phonetic workflows. It wires up asynchronous processing of LiteDevTools zipfiles and alignment tasks, provides monitoring/status endpoints, and serves downloadable metadata or annotated text for recorder and alignment tooling.",
        "short_summary": "This module defines Django views to collect, upload, and process human audio assets for CLARA projects. It handles form submissions for different acquisition methods, kicks off asynchronous processing jobs for LiteDevTools zipfiles and manual alignment, and provides monitoring and completion endpoints. It also exposes utilities to download audio metadata or annotated segmented text for external tools, with parallel support for phonetic data.",
        "key_responsibilities": [
          "Render and process forms/formsets for human audio uploads, manual alignment inputs, and phonetic audio settings tied to a project",
          "Initiate asynchronous tasks to process LiteDevTools zipfiles and manual alignment data, and provide polling/monitoring and completion views",
          "Persist uploaded audio files and metadata via AudioRepositoryORM, handling local/S3 file transfer as needed",
          "Serve downloadable audio metadata and labelled segmented text for recorder and alignment tooling (normal and phonetic variants)"
        ],
        "potential_issues": [
          "In the phonetic workflow, form validity is not checked and POST data is used directly, which may bypass validation and lead to inconsistent state",
          "The phonetic upload flow redirects to the non-phonetic view on formset validation error, which may be unintended",
          "Form saving restores existing file fields manually; if form.save clears file fields, incorrect restoration could occur if not carefully handled",
          "CLARAProjectInternal instances are passed to async tasks; if the task runner uses separate processes, pickling these objects may fail",
          "Local variable names shadow imported `messages` in status views, which could be confusing though not functionally harmful"
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "human_audio_processing",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'human_audio_processing' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Audio Processing",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.human_audio_views.human_audio_processing"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "human_audio_processing_phonetic",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'human_audio_processing_phonetic' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Audio Processing (Phonetic)",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.human_audio_views.human_audio_processing_phonetic"
        }
      ]
    }
  ],
  "clara_app/image_questionnaire_views.py": [
    {
      "created_at": "2025-12-22T19:57:37.970066+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5223,
        "completion_tokens": 3456,
        "total_tokens": 8679,
        "estimated_cost_usd": 0.04108875
      },
      "analysis": {
        "proposed_docstring": "Django view handlers for CLARA image questionnaires: listing eligible projects, preparing questionnaire sessions, rendering per-page rating forms for images (with optional text questions) and storing responses, plus summary and CSV export views. These views leverage CLARAProjectInternal to regenerate story and image data, track relevant elements for continuity questions, and localize UI labels. Session state is used to cache page data and inclusion flags, and helpers locate prior relevant pages for continuity comparisons.",
        "short_summary": "This module provides the web workflow for CLARA image questionnaires. It lets users search for projects with questionnaires, choose to include text-related questions, and then steps through each page with an image to collect ratings. It also includes summary views for individual users and aggregated results across projects, along with a CSV export of raw responses. Utility functions read relevant element data to determine continuity questions.",
        "key_responsibilities": [
          "List and filter CLARA projects that have image questionnaires enabled.",
          "Initialize and cache questionnaire page data in the session, including rendered text and relevant element frequency.",
          "Render per-page questionnaire forms with localized UI, handle navigation, and save/update ImageQuestionnaireResponse records.",
          "Provide user-level completion summaries and aggregated project summaries, and expose a CSV export of raw questionnaire responses.",
          "Helper functions to read relevant elements per page and locate prior pages sharing elements for continuity questions."
        ],
        "potential_issues": [
          "Pages and related data are stored in the session; with cookie-based sessions this could exceed size limits or be cleared, causing abrupt redirects to the summary.",
          "Only login is enforced; there is no check that the current user is authorized for a given project’s questionnaire.",
          "The aggregate summary uses question text from a static list, not localized, and entries with no responses include an unexpected \"search_form\" key, leading to inconsistent data passed to templates.",
          "Debug pprint of context in the item view may clutter logs or leak data in production.",
          "The session flag name include_text_in_image_and_text_questionnare is misspelled and may cause confusion or mismatch with other code."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:15:27.697829+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5223,
        "completion_tokens": 1562,
        "total_tokens": 6785,
        "estimated_cost_usd": 0.022148750000000002
      },
      "analysis": {
        "proposed_docstring": "Views for administering and participating in the image questionnaire flow for CLARA projects. This module lists eligible projects, initializes questionnaire state by generating rendered text and loading story data, and drives the per-page question display, submission, and navigation. It also provides per-user and global summaries and CSV export of collected ratings, and utility helpers for determining relevant elements across pages.",
        "short_summary": "This module implements the Django views that power an image (and optional text) questionnaire on CLARA projects. It filters and lists projects with questionnaires, initializes questionnaire state from project files, and guides users through page-by-page rating forms with localisation support. It provides summary pages and CSV exports of responses, and helper functions to detect continuity between pages.",
        "key_responsibilities": [
          "Present a filtered list of projects that have image questionnaires and handle questionnaire start routes for image-only or image-and-text modes.",
          "Initialize questionnaire sessions by rendering text for questionnaires, reading story data, determining available pages with images, and storing state in the session.",
          "Render individual questionnaire pages with images, text snippets, localised questions, and handle POST submissions to save or update ImageQuestionnaireResponse ratings and comments, including navigation between pages.",
          "Provide per-user summary of responses, aggregate summaries across all projects with averaged ratings, and export raw questionnaire data as CSV.",
          "Utility functions to read relevant elements per page and find prior pages sharing elements to enable continuity questions."
        ],
        "potential_issues": [
          "The raw CSV export and all-projects summary lack permission checks and could expose other users' responses to any authenticated user.",
          "Session storage of `image_questionnaire_pages` and include_text flags relies on prior start views; if session data is missing or cleared, users may be redirected unexpectedly.",
          "Debugging code prints the full context with `pprint`, which may log sensitive or large payloads in production.",
          "Question text in aggregated summaries and CSV is taken from hardcoded constants and not localised; UI and data export may not reflect translated strings.",
          "Reliance on file-based project data (story JSON, relevant elements, rendered HTML snippets) means missing or stale files can cause errors or skipped questions; error handling currently redirects with generic messages."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "image_questionnaire_project_list",
          "args_raw": [],
          "href_expr": "{% url 'image_questionnaire_project_list' %}",
          "element": "a",
          "attr": "href",
          "title": "Find projects with image questionnaires",
          "text": "Find image questionnaires",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.image_questionnaire_views.image_questionnaire_project_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "image_questionnaire_all_projects_summary",
          "args_raw": [],
          "href_expr": "{% url 'image_questionnaire_all_projects_summary' %}",
          "element": "a",
          "attr": "href",
          "title": "Show summary results for image quality questionnaires.",
          "text": "Questionnaire summary (images)",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.image_questionnaire_views.image_questionnaire_all_projects_summary"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "image_questionnaire_start",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'image_questionnaire_start' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Image questionnaire",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.image_questionnaire_views.image_questionnaire_start"
        }
      ]
    }
  ],
  "clara_app/images_v1_views.py": [
    {
      "created_at": "2025-12-22T19:57:51.371406+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 10936,
        "completion_tokens": 1399,
        "total_tokens": 12335,
        "estimated_cost_usd": 0.02766
      },
      "analysis": {
        "proposed_docstring": "Views for managing images and related AI workflows within a CLARA project. This module renders and processes the image editing interface, including handling uploads, deleting or archiving images, and synchronizing text versions per page. It orchestrates asynchronous DALL‑E‑3/GPT‑4 calls to generate coherent image sets, descriptive variables, and image request sequences, and exposes monitoring endpoints for those tasks. Utilities for validating generated sequences and accessing or restoring archived images are also provided.",
        "short_summary": "This module implements the image editing and generation views for CLARA projects. It prepares formsets with existing images and text versions, handles uploads, deletions, and description variables, and can launch asynchronous DALL-E and GPT-4 workflows to generate images or description sequences. It provides monitor endpoints for long-running tasks and views for browsing/restoring archived images.",
        "key_responsibilities": [
          "Render and process the edit-images page, including image uploads, deletion, text-version saving, and style image handling",
          "Trigger asynchronous generation of DALL‑E‑3 images, description variables, and image request sequences, with callback/report monitoring",
          "Validate and store GPT-generated description lists and image request sequences, ensuring consistency and initialization of description variables",
          "Execute coherent image generation/interpretation workflows (image-generation and image-understanding) and persist results via CLARAProjectInternal",
          "Expose task status/monitor endpoints and views for accessing, restoring, or deleting archived images"
        ],
        "potential_issues": [
          "HttpResponseNotAllowed is used in restore_image/delete_archive_image but not imported, which will raise NameError",
          "The style image form error message uses an undefined variable 'i' in messages.error",
          "Validation and indexing of text versions and page numbers may lead to off-by-one or missing-page edge cases, especially when generating placeholders",
          "check_and_correct_initialization_in_image_request_sequence silently drops uninitialized description variables from prompts, which may yield unexpected image prompts",
          "Overwriting of the imported 'messages' name within create_dall_e_3_image_status could be confusing, though locally scoped"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:15:54.270742+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 10936,
        "completion_tokens": 1395,
        "total_tokens": 12331,
        "estimated_cost_usd": 0.02762
      },
      "analysis": {
        "proposed_docstring": "Views for managing project images, including editing existing image metadata, generating and understanding images via DALL-E/GPT, and handling description variables for coherent image sets. Provides workflows to collect page texts, present and validate image and description formsets, trigger asynchronous tasks for image generation, description extraction, and syntax correction, and render status monitors. Also includes endpoints to poll task updates and access or restore archived images.",
        "short_summary": "This module defines the image editing and generation views for CLARA projects. It prepares formsets with page texts and existing image records, handles saving and deletion, and triggers asynchronous OpenAI-based tasks to generate images, description variables, and request sequences. Status endpoints are provided for task monitoring, and archived images can be listed, restored, or deleted.",
        "key_responsibilities": [
          "Render and process the image editing formset, including style image handling and description variable management.",
          "Trigger asynchronous tasks for DALL-E-3 image generation, GPT-4 based description extraction, and image request sequence creation, with status monitoring.",
          "Update and validate project page texts, falling back to async syntax correction if needed.",
          "Generate coherent image sets by chaining image-generation and image-understanding requests, storing results via CLARAProjectInternal.",
          "Provide endpoints to access, restore, or delete archived images through the ImageRepositoryORM."
        ],
        "potential_issues": [
          "HttpResponseNotAllowed is used in restore_image/delete_archive_image but not imported, which will cause a NameError on non-POST requests.",
          "Form handling relies on position/index alignment with initial_data; changes to ordering could misassociate uploads or page texts.",
          "Error handling around async tasks and OpenAI calls is minimal; exceptions may be swallowed or produce unclear user feedback.",
          "Direct indexing of page_texts by page-1 could raise out-of-range issues if page numbers are inconsistent with text lengths.",
          "Using style_description from a page-0 record assumes a specific ordering of initial_data that may not hold if upstream data changes."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "edit_images",
          "args_raw": [
            "project.id",
            "'no_dall_e_3_image'"
          ],
          "href_expr": "{% url 'edit_images' project.id 'no_dall_e_3_image' %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Edit Images and Pages",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.images_v1_views.edit_images"
        }
      ]
    }
  ],
  "clara_app/images_v2_views.py": [
    {
      "created_at": "2025-12-22T19:58:00.144768+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 7908,
        "completion_tokens": 665,
        "total_tokens": 8573,
        "estimated_cost_usd": 0.016535
      },
      "analysis": {
        "proposed_docstring": "Views for managing the v2 coherent image workflow in CLARA projects. This module renders and processes the edit page for images, handling form submissions to save parameters, advice, and page texts, delete elements or pages, and trigger asynchronous AI-driven generation of style, element, and page descriptions and images. It also exposes monitoring and status endpoints for background tasks and defines helper functions invoked asynchronously to perform generation, cost logging, and content policy checks.",
        "short_summary": "This module provides the edit view for coherent images v2, allowing authenticated project users to view and update image parameters, advice, and page texts, and to initiate AI-backed generation tasks. It orchestrates asynchronous tasks via django_q, reports status, and serves a monitor template. Helper functions wrap CLARAProjectInternal methods to generate style, element, and page images, log costs, and enforce content policy checks.",
        "key_responsibilities": [
          "Render and process the edit_images_v2 view for authenticated project users, handling multiple form actions (saving parameters, advice, texts; deleting elements/pages; creating overviews; downloading zip archives).",
          "Initiate asynchronous generation of style descriptions, element names and images, page descriptions and images, and variant images via django_q tasks and report progress/status.",
          "Update project state through CLARAProjectInternal (saving params, advice, texts, story data) and log API usage/costs.",
          "Expose JSON status and monitoring views for coherent image generation tasks.",
          "Perform content policy checks on generated assets and post task updates accordingly."
        ],
        "potential_issues": [
          "Many broad try/except blocks swallow exceptions and set generic error flags; underlying causes may be obscured.",
          "Page and element data assembly assumes consistent lengths of multiple text arrays and presence of keys in images dict; missing or out-of-range entries could lead to silent omission or errors.",
          "Duplicate import of get_element_names_params_from_project_params and unused variables (params_for_project_dir) suggest minor maintenance inconsistencies.",
          "Debug prints (_edit_images_v2_trace, print statements) are present and may clutter logs in production.",
          "Content policy violation checks rely on external helpers; misconfigured paths or params could misreport generation outcomes."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:16:38.854407+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 7908,
        "completion_tokens": 2401,
        "total_tokens": 10309,
        "estimated_cost_usd": 0.033895
      },
      "analysis": {
        "proposed_docstring": "Django views and background task helpers for managing coherent image set v2 within a CLARA project. This module renders and processes the main editing interface, allowing users to view and edit page texts and advice, adjust generation parameters, delete or download assets, and trigger AI-driven generation of style descriptions, element names, element/page descriptions, and images. It wires async tasks through django_q with status/monitor endpoints, relays cost and task updates, and interacts heavily with CLARAProjectInternal to persist changes and enforce content policy checks.",
        "short_summary": "Provides the edit_images_v2 view for configuring and managing coherent images for a CLARA project. Handles saving parameters and text content, deleting assets, downloading images, and kicking off asynchronous generation tasks for style, elements, and pages via django_q. Supplies monitoring/status endpoints and helper functions that interact with CLARAProjectInternal to generate content, store costs, and report task progress or errors. Broad exception handling flags inconsistencies and surfaces messages to the user.",
        "key_responsibilities": [
          "Render the edit_images_v2 page and populate forms/formsets with project parameters, texts, advice, and existing style/element/page images.",
          "Process POST actions to save parameters, background/style/element/page advice and texts, delete images or elements, create overview documents, and download image archives.",
          "Initiate and monitor asynchronous AI-driven tasks (style description/image, element names/descriptions/images, page descriptions/images, adding elements) using django_q, with callback/report IDs and status JSON/monitor views.",
          "Helper functions to drive CLARAProjectInternal generation methods, record API costs, and post task updates while checking for content policy violations."
        ],
        "potential_issues": [
          "actions_requiring_openai includes 'generate_variant_images', but the edit_images_v2 view does not handle this action; the create_variant_images helper may never be invoked.",
          "Building page_data assumes indexed_page_data is non-empty (uses max(...)) and only adds entries when a page exists in indexed_page_data, contrary to the comment about creating entries for pages with no image.",
          "coherent_images_v2_status assigns to a local variable named messages, shadowing django.contrib.messages and may be confusing; it also relies on 'error'/'finished' being present in the returned list of messages.",
          "Exception handling is very broad and sometimes simply flags the interface as inconsistent, which may mask underlying bugs or leave the UI without forms.",
          "The duplicate import of get_element_names_params_from_project_params is redundant and could indicate copy-paste issues."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "edit_images_v2",
          "args_raw": [
            "project.id",
            "'none'"
          ],
          "href_expr": "{% url 'edit_images_v2' project.id 'none' %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Edit Images and Pages",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.images_v2_views.edit_images_v2"
        }
      ]
    }
  ],
  "clara_app/language_game_views.py": [
    {
      "created_at": "2025-12-22T19:58:15.488507+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1068,
        "completion_tokens": 1541,
        "total_tokens": 2609,
        "estimated_cost_usd": 0.016745
      },
      "analysis": {
        "proposed_docstring": "Defines views for the Kok Kaper animal language game, including lazy loading and caching of the underlying game data from JSON, handling GET/POST workflows to build Kok Kaper and English sentences with associated images, and rendering appropriate templates with user selections persisted in the session.",
        "short_summary": "Provides the kok_kaper_animal_game view that drives a combinatorial language game for assembling animals, body parts and adjectives. It lazily loads and caches game data from a JSON file, restores and persists user selections via the session, and on POST constructs sentences and image paths while rendering either the game template or an unavailable notice with messages.",
        "key_responsibilities": [
          "Load and cache game configuration data from a JSON file via get_game_data() with graceful fallback on error.",
          "Handle GET and POST requests for the kok_kaper_animal_game view, restoring prior selections and toggles from the session.",
          "Look up selected animal, body part and adjective records to build Kok Kaper and English sentences and determine the appropriate image file.",
          "Persist user choices back into the session and render game or error templates with Django messages as needed."
        ],
        "potential_issues": [
          "The cached _GAME_DATA is never refreshed within a process, so updates to the JSON file require a restart to take effect.",
          "Using next() without a default on POSTed IDs will raise StopIteration if invalid or missing IDs are submitted.",
          "Defaults assume each game data list contains at least one element; empty lists would cause errors when accessing index 0.",
          "The boolean conversion for show_gloss relies on the presence of the POST key and may not handle unexpected values intuitively.",
          "The login_required decorator is commented out, so the game is currently accessible to unauthenticated users, which may be unintended."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:17:24.912558+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1068,
        "completion_tokens": 1215,
        "total_tokens": 2283,
        "estimated_cost_usd": 0.013484999999999999
      },
      "analysis": {
        "proposed_docstring": "Views for the Kok Kaper animal language game. This module loads and caches the game's JSON data, renders the game page with user-selected animals, body parts, and adjectives, constructs Kok Kaper and English sentences and image paths, and handles missing data with user-friendly messages and fallback templates.",
        "short_summary": "This module defines the view logic for the Kok Kaper animal game. It loads game data from a JSON file, caches it, and uses it to render a template with selectable animals, body parts, and adjectives. The view builds sentences and image paths based on POSTed selections, persists user choices in the session, and gracefully handles missing data or assets.",
        "key_responsibilities": [
          "Load and cache Kok Kaper game data from a JSON file via `get_game_data`",
          "Render the main game view, initializing selections and flags from the session and request",
          "Construct Kok Kaper and English sentences and image paths based on user selections",
          "Persist user selections back to the session and surface missing data or images via Django messages",
          "Render a fallback template when game data is unavailable"
        ],
        "potential_issues": [
          "Cached game data is never invalidated; updates to the JSON file will not be picked up until process restart",
          "If POSTed animal, part, or adjective IDs are invalid, `next(...)` lookups will raise StopIteration and error",
          "The bool conversion of `request.POST.get(\"show_gloss\")` may not reflect actual checkbox intent for non-empty strings",
          "Default selection assumes non-empty data lists; empty game data could cause errors in `_default`",
          "The commented-out `@login_required` means the view is accessible without authentication, which may or may not be intended"
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "kok_kaper_game",
          "args_raw": [],
          "href_expr": "{% url 'kok_kaper_game' %}",
          "element": "a",
          "attr": "href",
          "title": "Use the Australian language Kok Kaper to make pictures of funny animals",
          "text": "Kok Kaper animal game",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.language_game_views.kok_kaper_animal_game"
        }
      ]
    }
  ],
  "clara_app/language_masters_views.py": [
    {
      "created_at": "2025-12-22T19:58:30.006227+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1544,
        "completion_tokens": 1194,
        "total_tokens": 2738,
        "estimated_cost_usd": 0.013869999999999999
      },
      "analysis": {
        "proposed_docstring": "Admin-only Django views for managing language master assignments and localisation bundles. Provides forms and workflows to add or remove language masters, confirm deletions, and upload or edit key/text bundles with validation and messaging. Renders corresponding templates with user configuration context and persists changes via model get_or_create/update_or_create within transactions.",
        "short_summary": "This module defines administrator-restricted views to manage language master privileges and localisation bundles. It allows assigning and removing LanguageMaster records and provides a form to load, validate, and save LocalisationBundle contents. Templates are rendered with user configuration context and use Django's messaging framework for feedback.",
        "key_responsibilities": [
          "Render and process the AssignLanguageMasterForm to add language masters and list existing ones",
          "Handle confirmation and deletion of LanguageMaster entries",
          "Display, load, validate, and save localisation bundles composed of tab-separated key/text pairs",
          "Render admin templates with user configuration data and provide user feedback via messages"
        ],
        "potential_issues": [
          "The global config and the imported user_can_translate are unused, which may indicate stale code paths",
          "get_user_config must provide a 'clara_version' key or templates may fail if missing",
          "The post_localisation_bundle view overloads POST for both loading and saving actions; incorrect form submissions could hit unexpected branches",
          "No explicit success message is shown when adding language masters, and duplicate bundle item keys are simply overwritten without warning"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:17:56.126801+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1544,
        "completion_tokens": 1364,
        "total_tokens": 2908,
        "estimated_cost_usd": 0.015569999999999999
      },
      "analysis": {
        "proposed_docstring": "Views in this module support administrative management of language masters and localisation bundles. It exposes admin-only endpoints to list, assign and remove LanguageMaster privileges, and to create, load or save bundles of localisation strings. The views validate input, coordinate updates to the associated models within transactions, surface success and error messages, and render the relevant templates with configuration data for display.",
        "short_summary": "This module defines admin-restricted Django views for managing language master assignments and localisation bundles. It lets administrators add or remove LanguageMaster records and upload or load bundles of key–text pairs. The views use standard form handling, message feedback and template rendering with user configuration context.",
        "key_responsibilities": [
          "List existing LanguageMaster records and process assignments via AssignLanguageMasterForm for administrators.",
          "Confirm and delete LanguageMaster privileges by primary key.",
          "Provide an interface to load existing LocalisationBundle contents into a form and to validate and save uploaded bundles of key/TAB/text lines.",
          "Render management and confirmation templates with user configuration and feedback messages."
        ],
        "potential_issues": [
          "Imports for user_can_translate, get_config, config, and logger are unused, which could indicate leftover or missing functionality.",
          "The localisation bundle save routine updates or creates items but does not delete bundle items removed from the uploaded data, so stale keys may persist.",
          "Access control assumes a userprofile with an is_admin attribute; missing or misconfigured profiles could raise errors.",
          "Retrieving 'clara_version' from get_user_config may fail if that configuration key is absent."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "manage_language_masters",
          "args_raw": [],
          "href_expr": "{% url 'manage_language_masters' %}",
          "element": "a",
          "attr": "href",
          "title": "Give users 'language master' privileges, so that they can customise annotation prompts and edit phonetic lexicon data.",
          "text": "Manage language masters",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.language_masters_views.manage_language_masters"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "post_localisation_bundle",
          "args_raw": [],
          "href_expr": "{% url 'post_localisation_bundle' %}",
          "element": "a",
          "attr": "href",
          "title": "Post a localisation bundle so that language masters can define translations",
          "text": "Post a localisation bundle",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.language_masters_views.post_localisation_bundle"
        }
      ]
    }
  ],
  "clara_app/manipulate_project_views.py": [
    {
      "created_at": "2025-12-22T19:58:48.078772+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2385,
        "completion_tokens": 1853,
        "total_tokens": 4238,
        "estimated_cost_usd": 0.021511250000000003
      },
      "analysis": {
        "proposed_docstring": "Views for managing CLARA projects and their membership, including listing projects a user can access, updating project metadata, viewing project history, and deleting projects. These handlers enforce ownership or role-based access, coordinate with forms and Django messages, and render templates for project lists, details, member management, and confirmation pages. Some actions interact with the internal CLARA project representation to assess available text versions, up-to-date status, costs, and to perform cleanup on deletion. Menu rendering and feature availability are tailored based on user configuration and project languages.",
        "short_summary": "This module defines Django views to list, inspect, update, and delete CLARA projects, as well as to manage project members and view action history. It applies login and project role/ownership decorators, populates forms, and sends user feedback via messages. Project detail views calculate available processing steps and costs via the CLARA internal API and render the appropriate templates with context.",
        "key_responsibilities": [
          "List projects the current user owns or has permissions on, with search and pagination",
          "Manage project membership by adding and removing users with specific roles",
          "Display project details, available text versions, costs, and update project title or image set settings",
          "Confirm and perform deletion of a project and its associated internal resources",
          "Show a chronological history of actions performed on a project"
        ],
        "potential_issues": [
          "The remove_project_member view lacks an ownership/role check, so any authenticated user could potentially remove permissions if they know the permission ID",
          "Using ProjectPermissions.objects.get inside the project listing loop may trigger extra queries and could raise exceptions if permissions are missing despite the filter",
          "Duplicate import of is_chinese_language suggests possible confusion over function origin, and unused imports (operation cost/duration utilities) clutter the module",
          "Deletion relies on CLARAProjectInternal.delete(); failures in internal cleanup are not handled, potentially leaving orphaned internal resources",
          "The Q construction in project_list is unnecessarily wrapped and may be brittle; role determination assumes a ProjectPermissions entry exists for non-owners"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:18:37.438499+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2385,
        "completion_tokens": 1749,
        "total_tokens": 4134,
        "estimated_cost_usd": 0.02047125
      },
      "analysis": {
        "proposed_docstring": "Django views for managing CLARA projects, including membership administration, listing and filtering a user's projects, rendering project detail and history pages, and deleting projects. These views enforce login and project-level permissions, use various forms to update project metadata, and rely on CLARAProjectInternal to surface available text versions, rendering capabilities, and cost information. Templates are rendered with context about project state, user roles, and UI configuration.",
        "short_summary": "This module defines the project-related views: managing project members, listing projects a user has access to, deleting projects, showing project details, and displaying action history. Views are protected by login and project role/ownership decorators, and make use of forms and CLARAProjectInternal helpers to update and display project data. Rendering includes menus based on user configuration and CLARA version.",
        "key_responsibilities": [
          "Add and remove project members with specific roles using forms and owner-only access.",
          "List projects accessible to the current user with search filters and pagination, and annotate them with the user's role.",
          "Handle project deletion with confirmation and cleanup via CLARAProjectInternal.",
          "Render a project detail page showing available text versions, rendering capabilities, image flags, AI support, and allow updating title and image set options.",
          "Display the history of project actions for authorized users."
        ],
        "potential_issues": [
          "remove_project_member only requires login and does not enforce ownership or role checks, allowing any authenticated user to delete permissions if they know the ID.",
          "Determining the user's role in project_list uses ProjectPermissions.objects.get, which can raise exceptions if no matching permission exists or multiple exist; it also incurs N+1 queries.",
          "is_chinese_language is imported twice from different modules, potentially masking the intended implementation.",
          "Some CLARAProjectInternal calls and project deletions lack error handling, so failures could leave inconsistent state."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "project_list",
          "args_raw": [
            "'simple_clara'"
          ],
          "href_expr": "{% url 'project_list' 'simple_clara' %}",
          "element": "a",
          "attr": "href",
          "title": "List all the projects you have created or have been assigned a role in, using Simple-C-LARA.",
          "text": "List my C-LARA projects using Simple-C-LARA",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.manipulate_project_views.project_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "project_list",
          "args_raw": [
            "'full_clara'"
          ],
          "href_expr": "{% url 'project_list' 'full_clara' %}",
          "element": "a",
          "attr": "href",
          "title": "List all the projects you have created or have been assigned a role in.",
          "text": "List my C-LARA projects using Advanced C-LARA",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.manipulate_project_views.project_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "project_history",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'project_history' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "View Project History",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.manipulate_project_views.project_history"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "manage_project_members",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'manage_project_members' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Manage Project Members",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.manipulate_project_views.manage_project_members"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "delete_project",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'delete_project' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Delete Project",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.manipulate_project_views.delete_project"
        }
      ]
    }
  ],
  "clara_app/phonetic_lexicon_views.py": [
    {
      "created_at": "2025-12-22T19:59:25.254484+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4239,
        "completion_tokens": 3484,
        "total_tokens": 7723,
        "estimated_cost_usd": 0.04013875
      },
      "analysis": {
        "proposed_docstring": "Django views for managing phonetic lexicons and orthography data within C-LARA, aimed at language masters. Provides the main edit interface for reviewing and saving grapheme-to-phoneme correspondences and plain or aligned lexicon entries, including handling uploads of lexicon files. Coordinates asynchronous installation of plain lexicons with status polling and completion confirmation, and interacts with repository classes and templates to persist and present lexicon data.",
        "short_summary": "This module implements the views that allow a language master to edit and upload phonetic lexicon and orthography resources. The main edit view handles saving grapheme/phoneme data, reviewing generated lexicon entries, and uploading aligned or plain lexicon files. Plain lexicon imports are offloaded to a background task with supporting status and monitoring views.",
        "key_responsibilities": [
          "Render and process the phonetic lexicon edit form, including grapheme-to-phoneme correspondences, accent characters, and plain/aligned lexicon entry review.",
          "Validate and persist orthography and lexicon changes via PhoneticOrthographyRepository and PhoneticLexiconRepositoryORM, updating language encodings as needed.",
          "Handle uploads of aligned and plain lexicon files, copying to S3 when appropriate and initializing repository data from uploaded content.",
          "Kick off asynchronous plain lexicon import tasks using django_q, provide JSON status polling, and render monitoring/completion views."
        ],
        "potential_issues": [
          "Use of a local variable named \"messages\" in import_phonetic_lexicon_status shadows django.contrib.messages and may be confusing.",
          "The branch handling a missing language in edit_phonetic_lexicon sets an undefined grapheme_phoneme_correspondence_formset rather than grapheme_phoneme_formset, so formsets may retain stale data or be None unexpectedly in the template.",
          "Status detection in import_phonetic_lexicon_status only checks for exact \"error\" or \"finished\" strings in the task update list; unexpected message formats could leave status \"unknown\".",
          "Hard conversion of max_entries_to_show from config to int may raise if misconfigured, and the template may receive None for form or formsets if language selection is missing."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:19:26.993781+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4239,
        "completion_tokens": 1186,
        "total_tokens": 5425,
        "estimated_cost_usd": 0.01715875
      },
      "analysis": {
        "proposed_docstring": "Views for language masters to manage phonetic lexicons and orthography data. Provides a form-driven interface to refresh, edit, approve/delete plain and aligned lexicon entries, and update grapheme-to-phoneme correspondence and accent data. Supports uploading lexicon files, including an asynchronous import of plain lexicons with progress monitoring via django-q, and renders status/monitoring endpoints and completion redirects.",
        "short_summary": "This module implements Django views that allow authorized language masters to edit and import phonetic lexicon data. It handles saving orthography and lexicon entries, uploading aligned and plain lexicons (the latter via an asynchronous task), and provides endpoints to monitor and confirm import status. Templates are rendered with relevant formsets and progress data for user interaction.",
        "key_responsibilities": [
          "Render and process the phonetic lexicon editing form with formsets for grapheme–phoneme correspondences, accents, and lexicon entries.",
          "Persist encoding, orthography data, and approved or deleted plain/aligned lexicon entries through repository objects with validation.",
          "Handle file uploads for aligned and plain phonetic lexicons, kicking off asynchronous import of plain lexicons and redirecting to monitoring views.",
          "Expose JSON status for background imports and render monitoring/completion pages with user feedback."
        ],
        "potential_issues": [
          "Temporary files from aligned lexicon uploads are not explicitly removed, unlike plain uploads, which may lead to leftover files.",
          "The `messages` name is reused as a local variable in `import_phonetic_lexicon_status`, which could be confusing given the imported `messages` from `django.contrib`.",
          "If no language is selected or the form is invalid, some branches may leave formsets uninitialized and could lead to template errors if not guarded.",
          "Errors in consistency checks or empty selections result in user messages but the control flow continues; maintainers should ensure templates handle missing or None formsets."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "edit_phonetic_lexicon",
          "args_raw": [],
          "href_expr": "{% url 'edit_phonetic_lexicon' %}",
          "element": "a",
          "attr": "href",
          "title": "Upload or edit phonetic lexicon data for languages where you are a language master.",
          "text": "Edit phonetic lexicon",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.phonetic_lexicon_views.edit_phonetic_lexicon"
        }
      ]
    }
  ],
  "clara_app/profile_views.py": [
    {
      "created_at": "2025-12-22T19:59:38.528724+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1150,
        "completion_tokens": 1392,
        "total_tokens": 2542,
        "estimated_cost_usd": 0.0153575
      },
      "analysis": {
        "proposed_docstring": "Views for displaying and editing user profiles and managing friend relationships in the C‑LARA application. Provides an authenticated profile edit workflow, an external profile view that lets visitors send, accept or reject friend requests, and utilities to notify users by email and update the activity feed. Integrates with user and profile models, friend request forms, and includes the current C‑LARA version in template contexts. Email notifications are only sent in the UniSA deployment environment.",
        "short_summary": "This module defines profile-related views, including a login-protected profile editor and a public-facing profile page with friend request functionality. It handles form submission, validation, and saving for user and profile data, as well as creating, updating, and deleting FriendRequest records based on user actions. It also renders profile pages with contextual information and triggers notification emails when friend requests are sent.",
        "key_responsibilities": [
          "Render and process the user account and profile edit forms, saving changes and flashing success messages.",
          "Display external user profiles and determine friend request status between the current user and the profile being viewed.",
          "Handle sending, accepting, rejecting, cancelling, and unfriending actions via FriendRequestForm submissions and update the activity feed.",
          "Send HTML email notifications for new friend requests in the UniSA environment and include C-LARA version information in rendered templates."
        ],
        "potential_issues": [
          "The privacy check in external_profile references an undefined variable `user` instead of `profile_user`, which will raise a NameError or bypass privacy logic.",
          "external_profile is not login-protected but assumes a valid `request.user` for friend request actions, allowing anonymous users to initiate actions or causing errors.",
          "There are no authorization checks to ensure only the sender/receiver can accept or delete a friend request by ID, which could allow malicious manipulation.",
          "get_config() and logger are imported and set up but unused; friend request email notifications are only sent in a specific environment, potentially surprising in other deployments."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:19:46.938840+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1150,
        "completion_tokens": 1437,
        "total_tokens": 2587,
        "estimated_cost_usd": 0.0158075
      },
      "analysis": {
        "proposed_docstring": "Views for managing user profiles and friendship interactions. Provides a login-protected edit view for updating a user's own account and profile details via forms, and an external profile view that displays another user's profile and handles friend request actions. Integrates with utility functions to retrieve per-user configuration and record updates, renders profile-related templates, and sends notification emails on new friend requests.",
        "short_summary": "This module defines Django views for editing a user's own profile and for viewing other users' profiles with friend request management. It processes profile and friend request forms, updates associated models, and renders the appropriate templates. It also triggers update feed entries and notification emails when friend actions occur.",
        "key_responsibilities": [
          "Handle profile edit requests for authenticated users using UserForm and UserProfileForm",
          "Render external user profiles and manage friend request actions such as send, accept, cancel, reject, and unfriend",
          "Send notification emails when a new friend request is created",
          "Retrieve user-specific configuration and include it in profile-related views"
        ],
        "potential_issues": [
          "The private profile check in external_profile references an undefined variable 'user' instead of the profile user, which will raise a NameError when a profile is marked private",
          "external_profile is not protected by login_required and calls get_user_config(request.user), which may fail or behave unexpectedly for anonymous users",
          "There is no guard against creating duplicate friend requests or ensuring the requester is authenticated before creating/deleting them",
          "Email sending is gated on an environment variable and otherwise only prints, which may lead to missed notifications outside the specified environment"
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "edit_profile",
          "args_raw": [],
          "href_expr": "{% url 'edit_profile' %}",
          "element": "a",
          "attr": "href",
          "title": "Enter/edit your location, bio, profile picture etc.",
          "text": "Edit user profile",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.profile_views.edit_profile"
        }
      ]
    }
  ],
  "clara_app/public_api_views.py": [
    {
      "created_at": "2025-12-22T19:59:51.577235+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1039,
        "completion_tokens": 1151,
        "total_tokens": 2190,
        "estimated_cost_usd": 0.012808749999999999
      },
      "analysis": {
        "proposed_docstring": "Public API views to generate and serve a machine-friendly manifest of published content. It resolves a Content record by ID, reads compiled HTML pages from the project output directory, extracts plain text and image URLs, and assembles a structured manifest. The primary entry point is a GET endpoint that returns the manifest as JSON with strict no-cache and CORS headers for external consumers, while a helper builds the manifest dictionary. Filesystem utilities are used to locate and read page files; no templates are rendered.",
        "short_summary": "This module exposes a public-facing endpoint that returns a JSON manifest for a given Content object. It builds the manifest by traversing the compiled project output, converting HTML pages to plaintext and listing image sources. The GET view sets no-cache and cross-origin headers to support external clients such as LLMs.",
        "key_responsibilities": [
          "Handle GET requests for a content manifest and respond with a JSON payload and appropriate cache/CORS headers.",
          "Construct a manifest dictionary for a Content instance, including metadata and per-page plaintext and image URLs.",
          "Locate and read compiled HTML page files from the project output directory, converting HTML to text and extracting image sources."
        ],
        "potential_issues": [
          "Image extraction relies on a naive regex and may miss complex cases or break on unexpected HTML.",
          "Pagination stops at the first missing page file, which could skip subsequent pages if numbering is non-sequential.",
          "Assumes Content.project and related fields exist; missing relationships or attributes could raise exceptions when masking the author.",
          "Direct filesystem access is used without error handling, so missing or unreadable files will propagate errors or silently truncate the manifest.",
          "Headers such as Access-Control-Allow-Origin are set redundantly, and xframe_options_exempt may have security implications."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:20:19.421990+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1039,
        "completion_tokens": 1544,
        "total_tokens": 2583,
        "estimated_cost_usd": 0.01673875
      },
      "analysis": {
        "proposed_docstring": "Exposes a public JSON manifest endpoint for CLARA content, building metadata and page information for a given Content record. The module provides a GET view that assembles page data from compiled output files, converts HTML to plain text, extracts image URLs, and returns a manifest suitable for consumption by agents. Responses are configured to disable caching, allow cross-origin access, and include generation metadata. A helper constructs the manifest data structure, raising 404 when content is missing.",
        "short_summary": "This module defines a public API view to generate a JSON manifest for a content item. It loads a Content record, locates its compiled page HTML files, extracts text and image URLs, and returns structured metadata. The GET endpoint disables caching and enables CORS for broad consumption.",
        "key_responsibilities": [
          "Handle GET requests to serve a JSON manifest for a given content ID via public_content_manifest1.",
          "Fetch content metadata from the Content model and derive the project output directory to locate compiled HTML pages.",
          "Parse page HTML into plain text and collect image source URLs for inclusion in the manifest.",
          "Configure HTTP response headers to prevent caching and allow cross-origin access."
        ],
        "potential_issues": [
          "Accessing content.project.id and content.project.user assumes a related project exists; missing relations could raise errors.",
          "Author masking falls back to content.author if no project_id, which may not be present on the model.",
          "Image extraction uses a naive regex that may miss or misparse complex HTML and attributes.",
          "The loop over page_X.html continues until file_exists returns false; incorrect file_exists behavior could cause long or infinite loops.",
          "Open CORS and xframe_options_exempt may have security implications if the endpoint should be restricted.",
          "Response headers set Access-Control-Allow-Origin twice and include unused imports."
        ]
      }
    }
  ],
  "clara_app/reading_histories_views.py": [
    {
      "created_at": "2025-12-22T20:00:08.554462+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2873,
        "completion_tokens": 1457,
        "total_tokens": 4330,
        "estimated_cost_usd": 0.01816125
      },
      "analysis": {
        "proposed_docstring": "Django views for presenting and maintaining per-user reading histories by L2 language, including creation of backing CLARA projects, form handling for language selection, deletion and phonetic preferences, and adding new projects to a combined history via asynchronous compilation tasks. Provides monitor and status endpoints for polling task progress, and helpers to derive available languages and projects based on posted content and existing internalised texts.",
        "short_summary": "This module renders and processes the reading history page for a user and a chosen target language. It handles creating the underlying CLARA project for a new reading history, managing phonetic preferences, and dispatching asynchronous tasks to update and recompile the combined reading history when projects are added. Additional endpoints support polling task status, and helper functions filter eligible languages and projects based on stored content.",
        "key_responsibilities": [
          "Render the reading history view with forms and data for the current user/L2, and handle POST actions for language selection, deletion, phonetic preference updates, and adding projects",
          "Create associated CLARAProject and CLARAProjectInternal records when a new reading history is initialised",
          "Schedule and perform asynchronous updates of reading histories (compiling combined text with optional phonetics) and expose status/monitoring views for these tasks",
          "Determine available target languages and projects eligible to be added to a reading history based on posted content and presence of internalised texts"
        ],
        "potential_issues": [
          "If an unexpected POST action is received, the view may fall through without redirecting and attempt to render with undefined context variables",
          "Concurrent creation/deletion of reading histories and associated CLARA projects could lead to orphaned or missing internal resources",
          "The async task uses get_object_or_404 and object instances passed in; failures there may not be fully surfaced beyond generic error messages",
          "update_reading_history_status treats any message containing the substring 'error' or 'finished' as status, which may be brittle",
          "Helper functions rely on has_saved_internalised_and_annotated_text; if phonetic requirements are toggled, available language/project lists may not update as expected"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:21:17.680297+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2873,
        "completion_tokens": 2126,
        "total_tokens": 4999,
        "estimated_cost_usd": 0.02485125
      },
      "analysis": {
        "proposed_docstring": "Django views to manage a user's reading history per L2, including creation of associated CLARA projects, listing and removing items, toggling phonetic preferences, and adding new projects asynchronously. Exposes endpoints to kick off background compilation of a combined reading history, poll its status, and render monitoring pages, while populating templates with available languages, projects, and configuration. Helper routines enumerate L2 languages and projects with saved internalised text suitable for inclusion. Integrates closely with CLARAProjectInternal/ReadingHistoryInternal to render combined texts, including phonetic variants when requested.",
        "short_summary": "This module implements the UI and workflow around user reading histories, keyed by L2 language. It handles displaying and modifying a reading history, creating backing CLARA projects, and invoking background tasks to append projects and recompile combined texts. It also provides status endpoints and helper functions to determine eligible languages and projects based on stored content and phonetic resource availability.",
        "key_responsibilities": [
          "Render and process the reading_history view to select L2, delete histories, toggle phonetic text preference, and add projects to a history.",
          "Create associated CLARAProject and internal representations for a new reading history and check for rendered HTML availability.",
          "Kick off and monitor asynchronous update_reading_history tasks that combine component CLARA projects into a compiled reading history, with optional phonetic rendering.",
          "Expose JSON status polling via update_reading_history_status and a monitoring page that uses JavaScript to poll task progress.",
          "Enumerate available L2s and CLARA projects that have posted content and saved internalised texts for inclusion in a reading history."
        ],
        "potential_issues": [
          "The asynchronous task update_reading_history receives Django model instances and custom classes; depending on django_q serialization, passing these objects may lead to pickling or stale-state issues.",
          "Using get_object_or_404 in a background task may raise Http404 outside a request/response context; a simple get() with proper error handling may be more appropriate.",
          "Variable shadowing of the imported messages module in update_reading_history_status could be confusing, though contained within the function.",
          "If reading_history exists without an associated project (e.g. inconsistent data), access to reading_history.project will fail; deletion does not handle cleanup of rendered HTML beyond the current internal object.",
          "POST paths that do not hit a return may lead to undefined form/context variables before rendering; current logic assumes all POST branches redirect."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "reading_history",
          "args_raw": [
            "'english'",
            "'init'"
          ],
          "href_expr": "{% url 'reading_history' 'english' 'init' %}",
          "element": "a",
          "attr": "href",
          "title": "Access your reading history for a given language, or add a new project to it.",
          "text": "Reading histories",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.reading_histories_views.reading_history"
        }
      ]
    }
  ],
  "clara_app/registering_views.py": [
    {
      "created_at": "2025-12-22T20:00:21.271244+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1076,
        "completion_tokens": 994,
        "total_tokens": 2070,
        "estimated_cost_usd": 0.011285
      },
      "analysis": {
        "proposed_docstring": "This module is effectively a placeholder; the view logic for registering rendered project content has been moved to content_views.py. It previously offered endpoints to check for rendered HTML (normal or phonetic) and present a registration form, and to register a project's rendered content into the system with appropriate permission checks and update logging.",
        "short_summary": "This Django views module no longer defines active views; the content has been relocated. The commented code shows handlers for offering registration of rendered project content (normal or phonetic) and completing registration into the content model. It interacted with project models, user permissions, and forms before redirecting or rendering status templates.",
        "key_responsibilities": [
          "Placeholder indicating that registration-related view functions have been moved to content_views.py",
          "Previously checked for the existence of rendered HTML content and presented registration options for normal or phonetic renderings",
          "Handled POST submissions to register project content, enforcing owner permissions and logging updates"
        ],
        "potential_issues": [
          "The module contains only commented-out code; any URL patterns or imports still referencing these views will fail at runtime",
          "Stale imports and commented logic may confuse maintainers about the current location of functionality",
          "If the old code is re-enabled, permissions, form handling, and redirects should be reviewed against current models and templates"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:21:26.269521+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1076,
        "completion_tokens": 396,
        "total_tokens": 1472,
        "estimated_cost_usd": 0.005305
      },
      "analysis": {
        "proposed_docstring": "This module previously contained views for offering and handling registration of rendered project content but has since been superseded by content_views.py. It remains as a stub with the old logic commented out, noting that functionality has been relocated. Maintainers should look to content_views.py for the current implementations.",
        "short_summary": "This module no longer implements any active views; all prior logic for registering content has been commented out and moved elsewhere. It serves as a placeholder indicating that functionality now resides in content_views.py.",
        "key_responsibilities": [
          "Indicate that content registration views have been moved to content_views.py",
          "Retain commented reference code for offering and registering project content"
        ],
        "potential_issues": [
          "Contains only commented-out code, which may cause confusion about the source of actual view implementations",
          "If uncommented, imports and references may be outdated or missing in the current codebase",
          "Dead module may linger without purpose unless cleaned up or removed"
        ]
      }
    }
  ],
  "clara_app/rendering_views.py": [
    {
      "created_at": "2025-12-22T20:00:47.164501+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2347,
        "completion_tokens": 2666,
        "total_tokens": 5013,
        "estimated_cost_usd": 0.02959375
      },
      "analysis": {
        "proposed_docstring": "Views to initiate, monitor, and complete rendering of CLARA project texts, handling both normal and phonetic variants. This module validates required text versions, configures human or TTS audio preferences, and enqueues asynchronous rendering tasks via django-q using CLARAProjectInternal. It exposes a status API for client-side polling, displays progress and completion templates, and handles error reporting and registration of rendered content.",
        "short_summary": "This module defines Django views for starting CLARA text rendering jobs (normal or phonetic) and for monitoring their progress. It selects appropriate audio sources, schedules rendering as asynchronous tasks, and uses callbacks to report status updates. Supporting views render start, monitor, and completion pages and expose a JSON status endpoint for JavaScript polling.",
        "key_responsibilities": [
          "Validate that required text versions exist before initiating normal or phonetic rendering of a CLARA project.",
          "Determine human or TTS audio preferences and enqueue asynchronous rendering tasks with django-q using CLARAProjectInternal.",
          "Provide views to render start, monitor, status (JSON), and completion pages for rendering workflows, including error messaging.",
          "Set up and use callback/report IDs to collect task updates and convey success or failure to the user interface."
        ],
        "potential_issues": [
          "CLARAProjectInternal instances are passed directly into django-q tasks; if not serializable, this could fail or behave unexpectedly under distributed workers.",
          "The status endpoint only checks for literal 'error' or 'finished' messages; intermediate statuses are reported as 'unknown', which may not reflect progress accurately.",
          "Variable name 'messages' in render_text_status shadows django.contrib.messages, which could be confusing though scoped locally.",
          "render_text_start_phonetic_or_normal is undecorated and relies on being called internally; exposing it via URL without protections would bypass authentication/authorization.",
          "Completion view uses placeholder booleans for content_url/zipfile_url rather than actual URLs, so downstream functionality may be incomplete."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:21:53.880915+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2347,
        "completion_tokens": 825,
        "total_tokens": 3172,
        "estimated_cost_usd": 0.011183750000000001
      },
      "analysis": {
        "proposed_docstring": "Views for kicking off and monitoring the rendering of CLARA project texts, either in normal or phonetic form. This module enforces access control, validates that requisite text versions exist, and prepares audio preferences before enqueueing a background rendering task via django-q. It provides endpoints to poll and display task progress, and a completion view to present results or errors, working with associated models and user configuration to tailor the rendering workflow.",
        "short_summary": "This module orchestrates the rendering of CLARA project texts through Django views. It starts either normal or phonetic rendering jobs, delegates the heavy lifting to an asynchronous task, and provides polling and completion views to monitor progress. Audio source preferences and format/acknowledgement data are retrieved per project to drive rendering.",
        "key_responsibilities": [
          "Validate project state and user roles before initiating text rendering, checking for required text versions.",
          "Determine human vs. TTS audio settings and collect format and acknowledgement preferences for the render.",
          "Enqueue asynchronous rendering tasks with callbacks and unique report IDs, handling internalisation errors gracefully.",
          "Expose JSON status polling for client-side monitoring and render monitor/complete templates based on task state."
        ],
        "potential_issues": [
          "The async rendering function accesses Django models and may raise unexpected exceptions; errors are only reported via task updates.",
          "In render_text_start_phonetic_or_normal, internalised_text is fetched but unused, suggesting side effects or exceptions are relied upon; failures may not be obvious.",
          "Using a local variable named 'messages' in render_text_status shadows django.contrib.messages, which could be confusing if extended.",
          "Self-contained rendering is hardcoded to True and zipfile_url is always None; downstream consumers may expect other behaviors."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "render_text_start_normal",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'render_text_start_normal' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Render Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.rendering_views.render_text_start_normal"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "render_text_start_phonetic",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'render_text_start_phonetic' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Render Phonetic Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.rendering_views.render_text_start_phonetic"
        }
      ]
    }
  ],
  "clara_app/satisfaction_questionnaire_views.py": [
    {
      "created_at": "2025-12-22T20:01:01.264226+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1739,
        "completion_tokens": 1290,
        "total_tokens": 3029,
        "estimated_cost_usd": 0.015073749999999999
      },
      "analysis": {
        "proposed_docstring": "Views for handling satisfaction questionnaires within the CLARA app. This module provides endpoints for users to submit or edit feedback for a specific project, display an existing questionnaire response, and for authorized reviewers to manage responses via export or deletion. It also exposes a view aggregating questionnaire metrics and distributions for reporting templates. Templates are rendered for each workflow, with messaging and redirects used to guide user flow; data export leverages pandas/OpenPyXL to produce an Excel file.",
        "short_summary": "This module defines Django views around the satisfaction questionnaire feature. Authenticated users can fill out and update their responses per project, and view completed questionnaires. Reviewers can list, export, or delete responses, and an aggregation view computes averages and distributions for reporting.",
        "key_responsibilities": [
          "Render and process the satisfaction questionnaire form for a given project and user, updating or creating responses as needed.",
          "Display a read-only view of a specific user's questionnaire for a project.",
          "Provide a management interface for reviewers to list, export to Excel, or delete questionnaire submissions.",
          "Aggregate questionnaire data (averages, distributions, recent free-text answers) and render a summary template."
        ],
        "potential_issues": [
          "The aggregated_questionnaire_results view is not access-controlled, potentially exposing survey data to any visitor.",
          "show_questionnaire only checks login status and does not verify that the requesting user is authorized to view another user's response.",
          "manage_questionnaires assumes every reviewer has a userprofile with is_questionnaire_reviewer; missing profiles will raise errors.",
          "Exported Excel uses values() and may include sensitive fields or timestamps converted to naive without timezone context; content type is for Excel 97-2003 despite using an .xlsx writer.",
          "The get_config() and logger are unused, which may indicate incomplete configuration or logging omissions."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:22:11.067735+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1739,
        "completion_tokens": 895,
        "total_tokens": 2634,
        "estimated_cost_usd": 0.01112375
      },
      "analysis": {
        "proposed_docstring": "Views for handling satisfaction questionnaires associated with CLARA projects. This module provides endpoints for users to fill in or update their own questionnaire, view a submitted questionnaire, and for reviewers to manage responses, including exporting or deleting them. It also exposes an aggregation view that computes summary statistics and distributions of responses for reporting templates.",
        "short_summary": "This module contains Django view functions for the satisfaction questionnaire workflow. Authenticated users can submit and update their own questionnaires for a project, and view questionnaires. Questionnaire reviewers can list, export to Excel, or delete responses. An aggregation view computes averaged ratings and distributions for reporting templates.",
        "key_responsibilities": [
          "Render and process the satisfaction questionnaire form for a given project and the current user, creating or updating their response.",
          "Display a read-only questionnaire response for a specified project/user pair.",
          "Provide a management interface for questionnaire reviewers to list, export all responses to an Excel file, or delete selected submissions.",
          "Aggregate questionnaire data (averages, distributions, recent free-text answers) and render them for reporting."
        ],
        "potential_issues": [
          "The aggregation view has no access control; any visitor could access aggregate results unless protected elsewhere.",
          "show_questionnaire allows any authenticated user to view any user's questionnaire if they know the IDs, which may be a privacy concern.",
          "manage_questionnaires relies on a u.userprofile attribute; if a User lacks a related profile, user_passes_test will raise an error.",
          "Excel export and aggregation over all responses could be memory intensive with a large dataset and lacks pagination or streaming.",
          "Timezone conversion is applied only to the created_at field in exports; other datetime fields may remain timezone-aware if present.",
          "config and logger are initialized but not used in this module."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "aggregated_questionnaire_results",
          "args_raw": [],
          "href_expr": "{% url 'aggregated_questionnaire_results' %}",
          "element": "a",
          "attr": "href",
          "title": "Show summary results for satisfaction questionnaires.",
          "text": "Questionnaire summary (projects)",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.satisfaction_questionnaire_views.aggregated_questionnaire_results"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "manage_questionnaires",
          "args_raw": [],
          "href_expr": "{% url 'manage_questionnaires' %}",
          "element": "a",
          "attr": "href",
          "title": "Review and possibly delete questionnaires",
          "text": "Review questionnaires",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.satisfaction_questionnaire_views.manage_questionnaires"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "satisfaction_questionnaire",
          "args_raw": [
            "project.id"
          ],
          "href_expr": "{% url 'satisfaction_questionnaire' project.id %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Answer Satisfaction Questionnaire",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.satisfaction_questionnaire_views.satisfaction_questionnaire"
        }
      ]
    }
  ],
  "clara_app/save_page_texts_multiple_views.py": [
    {
      "created_at": "2025-12-22T20:01:10.471581+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 459,
        "completion_tokens": 866,
        "total_tokens": 1325,
        "estimated_cost_usd": 0.00923375
      },
      "analysis": {
        "proposed_docstring": "Views to monitor and report on the progress of a bulk \"save page texts\" operation for a CLARA project. Provides an endpoint to poll task updates and derive a simple status code, and a companion view to render a monitoring template for a given project and report. Access is restricted to authenticated users with a role on the target project.",
        "short_summary": "This module defines two views related to monitoring a multi-page text saving task. One view polls task updates by report ID and returns a JSON payload with messages and a derived status. The other renders a monitoring page for a given project and report. Both views enforce login and project role checks.",
        "key_responsibilities": [
          "Expose a JSON endpoint that fetches task update messages via get_task_updates and maps them to a simple status indicator.",
          "Render a monitoring page for a project's multi-page text saving process, passing project and report context to the template.",
          "Enforce that only authenticated users with an appropriate project role can access these monitoring endpoints."
        ],
        "potential_issues": [
          "Status derivation is based on naive membership checks for the strings 'error' or 'finished' in the messages payload; if get_task_updates returns a different structure or messages containing those substrings, the status could be misclassified.",
          "The function logs to stdout using print rather than using Django's logging facilities.",
          "There is no explicit error handling around get_task_updates; an invalid report_id could raise exceptions that aren't caught here.",
          "The JSON polling view does not verify the project context beyond the decorator, which may rely on report_id alone; ensure user authorization is appropriately enforced."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:22:49.217329+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 459,
        "completion_tokens": 1213,
        "total_tokens": 1672,
        "estimated_cost_usd": 0.012703750000000001
      },
      "analysis": {
        "proposed_docstring": "Defines views for monitoring the bulk \"save page texts\" process within a CLARA project. It exposes a JSON endpoint that polls task updates for a given report, inferring a simple status from those messages, and a monitor view that renders the monitoring template with project context. Access is restricted to authenticated users with a role on the project and relies on utils.get_task_updates to surface background task progress. The monitor view fetches the associated CLARAProject and passes project and report identifiers to the template for display.",
        "short_summary": "This module provides two Django views to monitor saving page texts for multiple items within a project. One view returns JSON containing task messages and an inferred status for a given report ID, and the other renders a monitoring page with project and report context. Both views require a logged-in user with appropriate project role.",
        "key_responsibilities": [
          "Provide a JSON status endpoint that polls get_task_updates for a given report and infers whether a background task has finished or errored",
          "Render the save_page_texts_multiple_monitor.html template with project and report context for monitoring purposes",
          "Enforce that users are authenticated and have a role on the referenced CLARAProject before accessing these views"
        ],
        "potential_issues": [
          "Status inference only checks for the substrings 'error' or 'finished' in messages; other states are treated as 'unknown'",
          "get_task_updates return type is assumed to support membership tests; unexpected types may lead to incorrect status detection",
          "Use of print statements for logging may not be appropriate in production and provides no structured logging",
          "Views accept any HTTP method unless restricted elsewhere, which may not be intended",
          "Messages are returned verbatim in JSON and could leak internal details if not sanitized"
        ]
      }
    }
  ],
  "clara_app/serving_content_views.py": [
    {
      "created_at": "2025-12-22T20:01:25.632390+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2206,
        "completion_tokens": 1722,
        "total_tokens": 3928,
        "estimated_cost_usd": 0.0199775
      },
      "analysis": {
        "proposed_docstring": "This module provides Django view functions for serving generated CLARA project content and media files, including rendered HTML pages, static and multimedia assets, project images, audio files, and downloadable zip archives. It locates files based on CLARA project metadata and utility helpers, supports both local filesystem and optional S3-backed storage, and applies basic protections such as login requirements for some endpoints and same-origin framing on rendered text. It also includes endpoints for delivering coherent image project assets with path normalization to mitigate traversal.",
        "short_summary": "Defines file-serving views for various CLARA project outputs and assets. Views resolve file paths using project information and utility helpers, optionally fetching from S3 if configured, and return appropriate HTTP responses or 404s. Some endpoints require authentication or apply clickjacking protections. Includes download endpoints for packaged zipfiles and exported projects.",
        "key_responsibilities": [
          "Serve rendered CLARA text HTML, static assets, and multimedia files by project and variant, with optional S3 support and clickjacking protection.",
          "Provide authenticated download of packaged content zipfiles and exported project archives based on CLARAProject metadata.",
          "Deliver project-related images, coherent image project overviews, and individual coherent image files with path normalization to prevent traversal.",
          "Serve audio files from the audio repository, requiring login and handling both local and S3-backed storage paths."
        ],
        "potential_issues": [
          "The S3 presigned URL branch in serve_export_zipfile references _s3_client and _s3_bucket_name, which are not imported and is noted as non-functional.",
          "serve_clara_image builds paths from a relative file path without explicit normalization, which could expose path traversal if absolute_file_name does not guard against it.",
          "Directly opening files for HttpResponse without using FileResponse may leave file descriptors open; reliance on GC may hide leaks under load.",
          "S3 object keys are constructed from absolute paths in several views, which may not correspond to actual keys in the bucket.",
          "Debug printing is used instead of logging, and exceptions in serve_zipfile are swallowed and re-raised as generic 404s, potentially obscuring errors."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:23:34.337491+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2206,
        "completion_tokens": 2379,
        "total_tokens": 4585,
        "estimated_cost_usd": 0.026547499999999998
      },
      "analysis": {
        "proposed_docstring": "Django views for serving CLARA-generated content and assets such as rendered HTML, coherent image overviews, zip exports, project images, and audio files from the filesystem or S3. Paths are resolved via CLARA project metadata and utility helpers, MIME types are guessed, and responses are returned directly without templating. Some endpoints require authentication and are configured for safe iframe embedding, with simple existence checks raising 404s on missing content. Includes support for downloadable zip archives of project output and exported content.",
        "short_summary": "This module exposes a collection of Django view functions that serve generated CLARA project assets directly over HTTP. It builds file paths from CLARA project IDs and metadata, retrieves content from local storage or S3, and returns appropriate HttpResponse/FileResponse objects. Several endpoints handle rendered texts, images, audio, and downloadable zip archives, with basic access control on sensitive resources.",
        "key_responsibilities": [
          "Serve rendered CLARA text, static, and multimedia files with proper MIME types and same-origin iframe allowance",
          "Provide download endpoints for project content zip files and export archives, optionally protecting them with login_required",
          "Serve project and CLARA images, coherent images overviews, and individual coherent image files with path resolution and traversal checks",
          "Expose audio file retrieval from the configured audio repository with optional S3-backed storage"
        ],
        "potential_issues": [
          "Presigned S3 URL branch in serve_export_zipfile references undefined _s3_client/_s3_bucket_name and is noted as non-functional",
          "serve_zipfile catches exceptions but raises Http404(\"error_message\") literal instead of the constructed error message",
          "File handles are opened without context managers in several views, which may leak descriptors under load",
          "Most file-serving views lack authentication and may expose generated content publicly",
          "Dual unquote imports (django.utils.http and urllib.parse) may be unintended and the former is shadowed"
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "serve_rendered_text",
          "args_raw": [
            "project.id",
            "'normal'",
            "'page_1.html'"
          ],
          "href_expr": "{% url 'serve_rendered_text' project.id 'normal' 'page_1.html' %}",
          "element": "a",
          "attr": "href",
          "title": null,
          "text": "Display Rendered Text",
          "template_repo_path": "clara_app/templates/clara_app/project_detail.html",
          "callable": "clara_app.serving_content_views.serve_rendered_text"
        }
      ]
    }
  ],
  "clara_app/simple_clara_views.py": [
    {
      "created_at": "2025-12-22T20:01:42.309141+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 19492,
        "completion_tokens": 1341,
        "total_tokens": 20833,
        "estimated_cost_usd": 0.037774999999999996
      },
      "analysis": {
        "proposed_docstring": "Views and helper functions powering the \"Simple C-LARA\" one-page wizard. This module inspects the state of a CLARA project, renders a consolidated form, and dispatches user-initiated actions either synchronously or via django-q background tasks. It wraps CLARAProjectInternal operations for text generation, segmentation, rendering, image generation/review (including coherent image set V2), TTS preferences, and posting content, while exposing polling endpoints for UI progress monitoring.",
        "short_summary": "This module implements the Simple C-LARA wizard views for creating and publishing multimedia CLARA texts from a single page. It collects project resources, renders and processes the form, and routes actions to synchronous helpers or background django-q tasks with progress reporting. It also provides review interfaces for coherent images (pages, elements, styles) and lightweight status/monitor endpoints for long-running jobs.",
        "key_responsibilities": [
          "Summarize project state (languages, title, texts, images, segmentation/rendering status) via get_simple_clara_resources_helper for pre-populating the wizard.",
          "Render and process the main simple_clara form, interpreting actions to create projects, generate/save texts, images, segmentation, TTS preferences, rendering, and posting.",
          "Dispatch Simple C-LARA actions to dedicated helper functions, running either in-process or in django-q workers and posting task updates for UI polling.",
          "Expose status and monitor views (simple_clara_status/monitor and execute_*_status/monitor) to support client-side polling of background tasks.",
          "Provide review and feedback views for coherent image set V2 (pages, elements, styles), including AI and user image generation requests, uploads, and voting."
        ],
        "potential_issues": [
          "execute_simple_clara_style_requests_monitor is missing the @login_required decorator (a bare `login_required` identifier), so access control may be broken.",
          "simple_clara and review views do not enforce project ownership/role beyond login; get_object_or_404 fetches any project by ID, which may allow unauthorized access unless constrained elsewhere.",
          "Errors returned from get_simple_clara_resources_helper (resources['error']) are not handled before accessing fields like resources['status'], which could raise KeyError.",
          "For rewrite_text, API calls are stored under the 'image' key; this may miscategorize costs/logging.",
          "Background tasks rely on post_task_update string markers; mismatches could lead to polling endpoints never detecting completion."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:23:51.797292+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 19492,
        "completion_tokens": 1014,
        "total_tokens": 20506,
        "estimated_cost_usd": 0.034504999999999994
      },
      "analysis": {
        "proposed_docstring": "High-level views and helpers for the Simple C-LARA one-page wizard. This module inspects a CLARA project’s current resources, renders the simplified authoring form, and interprets user actions to drive text creation, segmentation, rendering, TTS preferences, posting, and image workflows (including coherent image V2 review). It dispatches cheap actions synchronously and heavy operations to django-q background tasks, exposing monitoring/polling endpoints for progress. It wraps CLARAProjectInternal methods, tracks API usage/costs, and integrates community image feedback interfaces for pages, elements, and styles.",
        "short_summary": "This module powers the Simple C-LARA wizard: it renders the main form, detects available project resources, and dispatches user actions to create text, images, segmentation, rendering, and posting. Cheap actions run inline while expensive AI/image steps are enqueued to django-q, with status polling and monitor views. It also provides review interfaces for coherent images (pages, elements, styles) supporting community feedback, uploads, and votes.",
        "key_responsibilities": [
          "Inspect and summarize the current state of a CLARA project (texts, images, rendering, posting, TTS) for display in the wizard form.",
          "Handle the main Simple C-LARA view, mapping form actions to action dictionaries and executing them synchronously or via django-q tasks.",
          "Dispatch Simple C-LARA actions to helper functions that wrap CLARAProjectInternal operations, recording API calls and posting progress updates.",
          "Expose polling and monitor endpoints for long-running tasks and community feedback-driven image generation/review workflows.",
          "Provide page/element/style image review views with AI generation, uploads, voting, and promotion of preferred variants."
        ],
        "potential_issues": [
          "The decorator on execute_simple_clara_style_requests_monitor is missing '@login_required', so the view is not protected and the name `login_required` is left unused.",
          "Credit/key checks are only applied in some views; certain AI-dependent paths in review views might proceed without adequate authorization or balance checks.",
          "get_simple_clara_resources_helper returns a dict with an 'error' key instead of raising, but consumers assume 'status' exists; an error could cause KeyError downstream.",
          "create_v2_style_helper ignores the up_to_date_dict guard (commented out) and will recreate style assets even if already up to date.",
          "Redirect targets for errors/initial state are inconsistent (e.g., 'initial' vs 'init'), potentially causing broken navigation."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "simple_clara",
          "args_raw": [
            "0",
            "'initial'"
          ],
          "href_expr": "{% url 'simple_clara' 0 'initial' %}",
          "element": "a",
          "attr": "href",
          "title": "Create a new C-LARA project using Simple-C-LARA.",
          "text": "Create new C-LARA project using Simple-C-LARA",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.simple_clara_views.simple_clara"
        }
      ]
    }
  ],
  "clara_app/task_update_views.py": [
    {
      "created_at": "2025-12-22T20:01:47.767932+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 492,
        "completion_tokens": 520,
        "total_tokens": 1012,
        "estimated_cost_usd": 0.005815
      },
      "analysis": {
        "proposed_docstring": "Views for displaying and managing task update messages in the CLARA app. This module provides a user-facing page to list recent task updates for the logged-in user and an admin-only endpoint to purge old updates. It leverages Django's authentication decorators, fetches configuration and version information for rendering, and uses the TaskUpdate model to query or delete records based on time thresholds.",
        "short_summary": "This module defines Django views to show recent task updates to a logged-in user and to allow administrators to delete outdated task updates. It filters TaskUpdate records by recency and user, renders them with the current CLARA version, and uses Django's messaging framework to report deletion results.",
        "key_responsibilities": [
          "Render a list of task updates from the past hour for the current user.",
          "Retrieve and include the user's CLARA version in the task updates view.",
          "Provide an admin-restricted action to delete task updates older than 30 days.",
          "Use Django authentication decorators and messaging framework for access control and feedback."
        ],
        "potential_issues": [
          "The use of request.user.username as user_id assumes usernames match TaskUpdate.user_id; if TaskUpdate uses a different identifier, filtering may be incorrect.",
          "Hard-coded time windows (last 60 minutes for viewing, last 30 days for deletion) may not suit all deployments and are not configurable.",
          "The delete_old_task_updates view deletes old updates for all users, which may be unintended if per-user retention is desired.",
          "get_user_config is called without error handling; missing or malformed configuration could cause failures."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:24:15.742750+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 492,
        "completion_tokens": 777,
        "total_tokens": 1269,
        "estimated_cost_usd": 0.008385
      },
      "analysis": {
        "proposed_docstring": "Views for displaying recent task update messages to logged-in users and providing an administrative cleanup action. The module filters TaskUpdate records within a recent time window for the current user, renders them with configured CLARA version information, and allows admins to purge updates older than a set threshold with user feedback.",
        "short_summary": "This module defines Django views to show a user's recent task updates and to delete outdated update records. It leverages user-specific configuration for display and uses standard login and admin checks for access control, rendering a template with the relevant context or redirecting after cleanup.",
        "key_responsibilities": [
          "Retrieve and display TaskUpdate entries from the past hour for the authenticated user, ordered by timestamp.",
          "Fetch user configuration to include CLARA version information in the task updates view.",
          "Provide an admin-only endpoint to delete task updates older than 30 days and notify via Django messages.",
          "Enforce authentication and administrative checks on the exposed views."
        ],
        "potential_issues": [
          "TaskUpdate is filtered on user_id using the username; if the model expects a numeric user ID, this may not match and return no updates.",
          "get_user_config is assumed to return a dict with a 'clara_version' key; missing config could raise a KeyError.",
          "delete_old_task_updates deletes all old updates across all users without confirmation or per-user scoping, which might be unexpected.",
          "The imported config and logger are currently unused, and there is no error handling around database operations."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "delete_old_task_updates",
          "args_raw": [],
          "href_expr": "{% url 'delete_old_task_updates' %}",
          "element": "a",
          "attr": "href",
          "title": "Remove all task updates more than 30 days old.",
          "text": "Delete old task updates",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.task_update_views.delete_old_task_updates"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "view_task_updates",
          "args_raw": [],
          "href_expr": "{% url 'view_task_updates' %}",
          "element": "a",
          "attr": "href",
          "title": "Show trace output from C-LARA tasks produced during the last hour.",
          "text": "Recent task updates",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.task_update_views.view_task_updates"
        }
      ]
    }
  ],
  "clara_app/text_questionnaire_views.py": [
    {
      "created_at": "2025-12-22T20:02:08.201977+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 9348,
        "completion_tokens": 1785,
        "total_tokens": 11133,
        "estimated_cost_usd": 0.029535
      },
      "analysis": {
        "proposed_docstring": "Views for managing and running text questionnaires against books, including creation/editing by owners, evaluator landing pages with per-book progress, the multi-phase fill flow for per-page and whole-book Likert questions, and analytics/export of results. The module renders questionnaires and their per-page assets via CLARA project helpers, syncs linked books and questions, and supports public/owner listings and admin data purges. It also provides CSV/ZIP exports of aggregated or raw answers mirroring the results view.",
        "short_summary": "This module defines Django views for the lifecycle of text questionnaires: creating/editing questionnaires with linked books and questions, listing questionnaires for owners or the public, and allowing evaluators to fill them out page-by-page and at the whole-book level. It computes per-book progress, manages responses and answers, ensures rendered page assets exist, and provides analytics and CSV/ZIP exports as seen in the results view. Administrative utilities include deleting questionnaires and flushing all questionnaire data.",
        "key_responsibilities": [
          "Render and process creation/edit forms for TextQuestionnaire objects, syncing linked books and book-scope questions",
          "Provide evaluator-facing views to list assigned books with progress and to run questionnaires through per-page and whole-book phases, creating anonymous users as needed",
          "Ensure rendered page assets exist for per-page questions via CLARA project utilities and load per-page HTML/image snippets for display",
          "Compute questionnaire analytics for submitted responses and render results, with CSV/ZIP export of aggregated matrices, stats, and raw answer data",
          "Administrative actions such as deleting questionnaires, removing links, and purging all questionnaire-related data"
        ],
        "potential_issues": [
          "The module references traceback and now() in helper functions but does not import them, leading to NameError on error paths or date filtering",
          "Duplicate definitions of _sync_questions may cause confusion; the later version only deletes book-scope questions",
          "count_questionnaire_pages and asset loading assume a valid project and filesystem state; missing projects or compiled pages can raise errors or miscount requirements",
          "load_questionnaire_page_html is called in tq_fill but its result is not used; ensure intended asset is actually rendered",
          "Progress and completion logic depends on filesystem page counts; discrepancies between counted pages and stored answers may reopen submitted responses unexpectedly",
          "Anonymous user creation may leave unused User records; no cleanup is provided"
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:24:40.216619+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 9348,
        "completion_tokens": 759,
        "total_tokens": 10107,
        "estimated_cost_usd": 0.019275
      },
      "analysis": {
        "proposed_docstring": "Views for creating, editing, filling, and analysing text questionnaires tied to book content. This module handles questionnaire lifecycle (owner-facing creation, linking books and questions), evaluator flows for per-page and whole-book Likert responses (with anonymous user support), and renders progress, results, and CSV/ZIP exports. It also provides helper routines to synchronise linked books/questions, ensure rendered page assets exist, and compute aggregated statistics for results pages.",
        "short_summary": "This module implements the views around text questionnaires: owners can create/edit questionnaires, link books, and manage questions, while evaluators can browse assigned books, fill per-page and whole-book Likert questions, and track progress. It renders intro/page/book phases, computes completion, and records answers. Owners can view aggregated results and export CSV/ZIP data. Helpers render book pickers, sync links/questions, and ensure rendered page assets exist for per-page questions.",
        "key_responsibilities": [
          "Render and process forms to create and edit questionnaires, link books, and define per-book and per-page questions.",
          "Provide evaluator-facing views to list assigned books, fill per-page and whole-book Likert questions, handle anonymous users, and track granular progress.",
          "Ensure rendered page assets for questionnaires exist via CLARAProjectInternal utilities and load per-page HTML/image snippets.",
          "Render owner-facing results pages with aggregated statistics/matrices and support exporting aggregated and raw CSV/ZIP data.",
          "Utility functions to synchronise linked books and questions, render paginated book picker partials, and parse per-page question text."
        ],
        "potential_issues": [
          "traceback and now are referenced in error handling/helper code but not imported, which will raise NameError on exceptions or when filtering by time period in the book picker.",
          "There are two definitions of _sync_questions; the latter shadows the former and deletes only book-scope questions, which may be unintended or confusing.",
          "tq_export_csv and other views allow admin via userprofile checks but tq_results restricts strictly to owners; access control may be inconsistent.",
          "tq_fill assumes a project exists on the linked book or its content; missing project associations will break per-page phase.",
          "ensure_q_pages_ready/load_q_page_assets rely on external rendering utilities; failures are caught only broadly and may mask underlying issues, with printed debug statements left in production."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "tq_create",
          "args_raw": [],
          "href_expr": "{% url 'tq_create' %}",
          "element": "a",
          "attr": "href",
          "title": "Create and post a new text questionnaire",
          "text": "Create text questionnaire",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.text_questionnaire_views.tq_create"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "tq_my_list",
          "args_raw": [],
          "href_expr": "{% url 'tq_my_list' %}",
          "element": "a",
          "attr": "href",
          "title": "Find posted text questionnaires",
          "text": "My text questionnaires",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.text_questionnaire_views.tq_my_list"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "tq_public_list",
          "args_raw": [],
          "href_expr": "{% url 'tq_public_list' %}",
          "element": "a",
          "attr": "href",
          "title": "Edit text questionnaires I have created",
          "text": "Find posted text questionnaires",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.text_questionnaire_views.tq_public_list"
        }
      ]
    }
  ],
  "clara_app/update_feed_views.py": [
    {
      "created_at": "2025-12-22T20:02:17.079455+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 695,
        "completion_tokens": 809,
        "total_tokens": 1504,
        "estimated_cost_usd": 0.00895875
      },
      "analysis": {
        "proposed_docstring": "This module defines the authenticated view responsible for rendering a user's update feed, aggregating recent activity by the user and their friends. It queries Update records, limits to the latest 50, filters out entries that cannot be rendered, and passes them to a template along with user-specific configuration. Helper logic validates that each update's content_object matches the expected models for its update_type before inclusion in the feed.",
        "short_summary": "Provides the update feed view for logged-in users, assembling recent updates by the user and their friends. Retrieves and filters Update instances for validity before rendering the feed template with user configuration context.",
        "key_responsibilities": [
          "Retrieve current user's friends and query recent Update records involving them or the user.",
          "Validate update entries against expected model types for each update_type before displaying.",
          "Render the update feed template with the filtered updates and user-specific settings such as clara_version."
        ],
        "potential_issues": [
          "The 'PUBLISH' branch in valid_update_for_update_feed checks that content_object is both a Comment and a Content, which can never be true, likely preventing publish updates from appearing.",
          "Invalid or unexpected updates are silently filtered out with only a print warning, which may hide data issues in production.",
          "The module-level config from get_config() is defined but unused, which may indicate leftover or redundant code."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:25:07.616683+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 695,
        "completion_tokens": 1204,
        "total_tokens": 1899,
        "estimated_cost_usd": 0.01290875
      },
      "analysis": {
        "proposed_docstring": "Views for rendering a user's activity feed, showing recent updates made by the user and their friends. Retrieves recent Update records, filters them for expected types, and renders them into the update feed template along with configuration like the Clara version. Includes validation logic to ensure only updates with compatible content objects are passed to the template.",
        "short_summary": "This module exposes a login-protected view that assembles and renders a feed of recent updates for the current user and their friends. It queries Update records, validates them against expected model types, and passes the filtered list to the 'clara_app/update_feed.html' template along with the user's configuration. A helper ensures only updates with renderable content are included.",
        "key_responsibilities": [
          "Provide the update_feed view to display a user's own and friends' recent updates.",
          "Query and order recent Update objects, limiting to the latest 50 entries.",
          "Filter updates through valid_update_for_update_feed to ensure they have the expected related model instances before rendering.",
          "Retrieve user-specific configuration (e.g., Clara version) and pass context to the update feed template."
        ],
        "potential_issues": [
          "The PUBLISH case in valid_update_for_update_feed checks that content_object is both Comment and Content, which is impossible and likely a bug; it probably should check Content instead of Comment.",
          "Warnings for invalid updates are printed to stdout rather than logged, and are silently filtered out, which may hide underlying data issues.",
          "The module defines a config variable and logger but does not use them, suggesting incomplete or stale code.",
          "If get_user_config or current_friends_of_user fails or performs expensive queries, the feed view may error or be slow without handling."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "update_feed",
          "args_raw": [],
          "href_expr": "{% url 'update_feed' %}",
          "element": "a",
          "attr": "href",
          "title": "Get a summary of recent C-LARA activity from you and your friends.",
          "text": "Update feed",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.update_feed_views.update_feed"
        }
      ]
    }
  ],
  "clara_app/user_config_views.py": [
    {
      "created_at": "2025-12-22T20:02:28.107028+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 484,
        "completion_tokens": 1159,
        "total_tokens": 1643,
        "estimated_cost_usd": 0.012195000000000001
      },
      "analysis": {
        "proposed_docstring": "View logic for displaying and updating per-user configuration. This module exposes the authenticated user_config view, ensuring a UserConfiguration record exists, binding it to a form for editing, and persisting changes with feedback messages. It also passes along the current Clara version from utility helpers for rendering in the user configuration template.",
        "short_summary": "Provides a single authenticated view for users to manage their configuration settings. The view will create a UserConfiguration record if missing, bind it to a form for GET/POST, and save valid submissions with a success message. It fetches Clara version information to include in the rendered template.",
        "key_responsibilities": [
          "Expose the login-protected user_config view for rendering and processing user configuration forms.",
          "Ensure a UserConfiguration instance exists for the current user, creating one on legacy accounts as needed.",
          "Bind and validate UserConfigForm data, saving updates and providing Django messages and redirects on success.",
          "Include Clara version information from utilities when rendering the user configuration template."
        ],
        "potential_issues": [
          "The module-level config and logger variables are initialized but never used.",
          "If get_user_config does not return a dict with 'clara_version', rendering will raise a KeyError.",
          "No explicit handling or feedback is provided for invalid form submissions aside from re-rendering the form with errors.",
          "get_or_create will create a UserConfiguration with defaults; if additional required fields are later added to the model, this may fail or create incomplete records."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:25:19.877980+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 484,
        "completion_tokens": 554,
        "total_tokens": 1038,
        "estimated_cost_usd": 0.006144999999999999
      },
      "analysis": {
        "proposed_docstring": "Views for displaying and updating a user's configuration settings. This module currently exposes a login-protected view that ensures a UserConfiguration object exists for the authenticated user, binds form data for updates, persists changes, and displays success messages. It pulls auxiliary configuration data such as the Clara version to render into the user configuration template.",
        "short_summary": "This module defines the user configuration view, allowing authenticated users to create or update their configuration settings via a form. It ensures a configuration record exists, validates and saves changes on POST, and renders the configuration page with contextual data such as the Clara version.",
        "key_responsibilities": [
          "Expose a login-required view for managing user configuration settings.",
          "Ensure a UserConfiguration model instance exists for the current user.",
          "Bind and validate UserConfigForm data, save changes, and provide feedback via Django messages.",
          "Render the user configuration template with the form and additional configuration context."
        ],
        "potential_issues": [
          "The imported `get_config`/`config` and logger are not used within the module, which may indicate leftover code.",
          "If `get_user_config(request.user)` does not include a `clara_version` key or raises an error, the view will fail when rendering.",
          "On invalid form submissions, no error handling or messages are provided; the form is simply re-rendered."
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "user_config",
          "args_raw": [],
          "href_expr": "{% url 'user_config' %}",
          "element": "a",
          "attr": "href",
          "title": "Specify the GPT-4 model you want to use, optionally give an API key, and edit other related parameters.",
          "text": "Edit configuration information",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.user_config_views.user_config"
        }
      ]
    }
  ],
  "clara_app/users_and_friends_views.py": [
    {
      "created_at": "2025-12-22T20:02:35.086920+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 632,
        "completion_tokens": 736,
        "total_tokens": 1368,
        "estimated_cost_usd": 0.008150000000000001
      },
      "analysis": {
        "proposed_docstring": "Views for listing users and displaying friendship information. Provides a paginated user search/sort view and a friends dashboard showing incoming/outgoing friend requests, current friends, and configuration details for the logged-in user. These views require authentication and render HTML templates with the appropriate context data pulled from Django's auth User model and related utilities.",
        "short_summary": "This module defines two authenticated Django views for user and friend management. It lets logged-in users browse and search all users with sorting and pagination, and view their own friend-related information including requests and current friends. It renders the corresponding templates with context built from the auth models and helper utilities.",
        "key_responsibilities": [
          "Handle authenticated requests to list and search users with sorting and pagination.",
          "Collect and render incoming/outgoing friend request data and current friends for the logged-in user.",
          "Populate templates with user profile and configuration details retrieved via utility functions."
        ],
        "potential_issues": [
          "Assumes every User has an associated userprofile; missing profiles could raise an AttributeError.",
          "User.objects.all() may include the requesting user and can be large without additional filtering or pagination size controls.",
          "Sort parameter defaults to date_joined but lacks validation of unexpected values.",
          "Imported config and logger are unused, suggesting dead code or missing instrumentation."
        ]
      }
    },
    {
      "created_at": "2025-12-23T12:25:48.057423+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 632,
        "completion_tokens": 1557,
        "total_tokens": 2189,
        "estimated_cost_usd": 0.01636
      },
      "analysis": {
        "proposed_docstring": "Defines login-protected views for listing users and managing friendships within the Clara app. Provides endpoints to render a paginated list of users with optional username search and sorting, and to display the current user's friendship status including incoming and outgoing friend requests, current friends, and user-specific configuration such as Clara version. Interacts with the built-in User model, a FriendRequest model, helper utilities, and renders corresponding templates.",
        "short_summary": "This module implements two Django views requiring authentication. The user listing view filters, sorts, and paginates all users and renders them in a template. The friends view collects the logged-in user's profile, pending friend requests, current friends, and configuration to display a friendship management page. It uses helper utilities and models to assemble the context for the templates.",
        "key_responsibilities": [
          "Render a paginated list of users with optional search by username and sorting by username or join date",
          "Retrieve and display the current user's profile, incoming/outgoing friend requests, and current friends",
          "Fetch user-specific configuration (e.g., Clara version) to include in the friends page context",
          "Coordinate database queries and pass context to the appropriate templates for rendering"
        ],
        "potential_issues": [
          "Assumes every authenticated user has an associated userprofile attribute; missing profiles will raise errors",
          "The current user is not excluded from the user list, which may or may not be intended",
          "Unused configuration and logger variables suggest leftover or incomplete instrumentation",
          "No handling for unexpected sort parameters beyond defaulting to date joined ordering"
        ]
      },
      "ui_entrypoints": [
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "list_users",
          "args_raw": [],
          "href_expr": "{% url 'list_users' %}",
          "element": "a",
          "attr": "href",
          "title": "Show all users. You can send friend requests to users with public profiles.",
          "text": "Users",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.users_and_friends_views.list_users"
        },
        {
          "attached_at": "2025-12-27T05:21:48.748505+00:00",
          "url_name": "friends",
          "args_raw": [],
          "href_expr": "{% url 'friends' %}",
          "element": "a",
          "attr": "href",
          "title": "Show friends and outstanding friend requests.",
          "text": "Friends",
          "template_repo_path": "clara_app/templates/clara_app/base.html",
          "callable": "clara_app.users_and_friends_views.friends"
        }
      ]
    }
  ],
  "clara_app/clara_acknowledgements.py": [
    {
      "created_at": "2025-12-23T11:41:11.088504+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 538,
        "completion_tokens": 1055,
        "total_tokens": 1593,
        "estimated_cost_usd": 0.0112225
      },
      "analysis": {
        "proposed_docstring": "Utility functions for attaching acknowledgement information to a CLARA Text object. The module exposes a helper that inspects an acknowledgements_info structure and mutates the text object's pages by injecting a long acknowledgement segment either on the first page or as a new trailing page, and by annotating other pages with a short acknowledgement. It operates on the custom Text, Page, Segment, and ContentElement classes, extending their pages, segments, and annotations in place.",
        "short_summary": "Provides a helper to add acknowledgements to a text object composed of pages, segments, and content elements. Depending on whether a long acknowledgement is provided and where it should appear, it injects an extra segment or page and annotates remaining pages with a short acknowledgement. Mutates the provided Text-like object in place, leveraging custom classes from clara_classes.",
        "key_responsibilities": [
          "Expose add_acknowledgements_to_text_object to incorporate acknowledgement information into a Text object",
          "Create non-word content elements and segments for long acknowledgement text and insert them into existing or new pages",
          "Annotate pages with short acknowledgement text based on whether a long acknowledgement is present and its desired location"
        ],
        "potential_issues": [
          "Assumes text_object.pages exists and contains at least one page when inserting a long acknowledgement on the first page; will raise an IndexError on empty content",
          "Assumes acknowledgements_info has short_text, long_text, and long_text_location attributes without validation",
          "Relies on Page.annotations being an initialized dict; assignment may fail or overwrite existing keys",
          "Only distinguishes 'first_page' versus any other long_text_location value; unexpected values fall into the \"add new page at end\" branch"
        ]
      }
    }
  ],
  "clara_app/clara_align_with_segmented.py": [
    {
      "created_at": "2025-12-23T11:41:42.158333+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2196,
        "completion_tokens": 749,
        "total_tokens": 2945,
        "estimated_cost_usd": 0.010235000000000001
      },
      "analysis": {
        "proposed_docstring": "Utility module for aligning a segmented text representation with another version lacking explicit segmentation while preserving structural tags and annotations. It converts text into internal DiffElement sequences, runs difflib-based comparison to reconcile differences, fills in placeholder annotations where needed, and reconstructs a Text object back into a string for a specified annotation type. Helper functions handle conversion between raw strings and Text/Page/Segment/ContentElement structures and cleaning up trailing empty pages.",
        "short_summary": "This module aligns a segmented text with a non-segmented counterpart using difflib sequence matching and placeholder annotations. It provides conversions between raw text strings, internal DiffElement lists, and Text objects to preserve page/segment structure. It also includes helper logic to generate placeholder annotations and strip empty pages.",
        "key_responsibilities": [
          "Align a segmented text with a non-segmented variant by matching DiffElement content and inserting placeholder annotations where segments are missing",
          "Convert between raw text, DiffElement lists, and Text/Page/Segment/ContentElement objects to maintain structural and annotation data",
          "Generate appropriate placeholder annotations for different annotation types (mwe, translated, lemma, gloss)",
          "Provide a helper to remove trailing empty pages from a text string"
        ],
        "potential_issues": [
          "Uses difflib.SequenceMatcher on content lists, which may yield unexpected alignments and placeholder insertions if inputs differ significantly",
          "Insert operations in the non-segmented text are discarded, potentially losing data",
          "Tag detection is based on string equality of element.content (e.g. '<page>', '<segment>'), so malformed or mismatched tags could corrupt reconstruction",
          "remove_any_empty_pages_at_end naively splits on the literal '<page>' substring and may misbehave if that token appears in content"
        ]
      }
    }
  ],
  "clara_app/clara_annotated_images.py": [
    {
      "created_at": "2025-12-23T11:41:57.480077+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1503,
        "completion_tokens": 625,
        "total_tokens": 2128,
        "estimated_cost_usd": 0.00812875
      },
      "analysis": {
        "proposed_docstring": "Utility functions for associating annotated images with segmented text in C-LARA. This module can build an initial annotation structure from segmented text, insert image content elements into a Text at a specified page position, and transform image metadata and associated areas into ContentElement representations with dimensions and coordinate annotations. It relies on internal Text/Page/Segment models and helpers to compute file basenames and image dimensions.",
        "short_summary": "This module provides helpers for integrating annotated images into C-LARA text structures. It can produce a skeleton annotation structure from segmented text, insert an image element into the appropriate page/segment, and convert an image with associated areas into a ContentElement with dimensions and transferred coordinates.",
        "key_responsibilities": [
          "Create an uninstantiated annotated image structure from segmented text using internalize_text.",
          "Insert image content elements into a Text object's pages and segments based on image metadata (page, position).",
          "Convert image objects to ContentElement instances, including image dimensions, thumbnails, and mapping associated area coordinates onto word elements via difflib matching."
        ],
        "potential_issues": [
          "Assumes the number of segments in image.page_object matches the length of associated_areas['segments']; zip will silently drop extras.",
          "Coordinates mapping uses SequenceMatcher on word content; changes in tokenization or mismatches may lead to misaligned annotations.",
          "Non-word content elements are discarded when mapping coordinates, which may affect positioning if the text contains punctuation or other elements.",
          "The add_image_to_text logic only supports 'top' and 'bottom' positions and may not handle other placement needs.",
          "No error handling for missing or malformed associated_areas JSON; transformed_segments becomes None without further checks."
        ]
      }
    }
  ],
  "clara_app/clara_audio_annotator.py": [
    {
      "created_at": "2025-12-23T11:42:48.248100+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 6877,
        "completion_tokens": 2647,
        "total_tokens": 9524,
        "estimated_cost_usd": 0.03506625
      },
      "analysis": {
        "proposed_docstring": "Module implementing the AudioAnnotator helper that prepares, generates, and attaches audio assets to internal Text objects. It coordinates text-to-speech engines or imported human recordings, stores resulting MP3 files in the audio repository, and annotates words, segments, and pages with playback metadata. The class also supports processing LiteDevTools zip bundles and manual alignment metadata to ingest human audio, and can concatenate segment audio into full-page recordings. Progress callbacks and context-aware canonicalisation are used throughout to manage different languages, voices, and phonetic modes.",
        "short_summary": "Provides an AudioAnnotator for generating or ingesting audio for words, segments, and pages within Text objects. It orchestrates TTS engine selection, canonicalises text, stores MP3s in an AudioRepository, and updates the Text structure with audio metadata. The module also handles human audio imports from LiteDevTools exports or manual alignment data.",
        "key_responsibilities": [
          "Select and configure TTS engines, voices, and languages for word, segment, and phonetic audio generation or human voice usage.",
          "Collect existing audio metadata from the repository, detect missing files, and generate/store new MP3s as needed.",
          "Annotate Text pages, segments, and words with audio metadata (engine, language, voice, file path) and optional page-level concatenated audio.",
          "Ingest human audio from LiteDevTools zip files or manual alignment metadata, storing recordings in the repository with context-aware keys.",
          "Provide utility helpers for audio concatenation and detection of text with no audio content."
        ],
        "potential_issues": [
          "Missing detection ignores context when identifying absent audio, which may conflate entries that differ only by context.",
          "Subprocess ffmpeg concatenation is invoked without error handling or return-code checks, so failed concatenations may go unnoticed.",
          "Placeholder file paths ('placeholder.mp3') are assigned for missing audio without ensuring the file exists, which could break playback.",
          "If TTS engine creation or language/voice lookup fails (engine_id is None), later operations may silently skip audio generation.",
          "String filtering for audio content may misclassify text comprised of tags or punctuation, potentially omitting valid content."
        ]
      }
    }
  ],
  "clara_app/clara_audio_repository_orm.py": [
    {
      "created_at": "2025-12-23T11:43:19.825166+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2511,
        "completion_tokens": 1552,
        "total_tokens": 4063,
        "estimated_cost_usd": 0.018658749999999998
      },
      "analysis": {
        "proposed_docstring": "Implements a file-backed audio repository using the Django ORM to persist metadata about human and TTS-generated voice recordings. The AudioRepositoryORM class initializes the repository directory, adds and updates AudioMetadata records, stores MP3 files in a structured directory tree, retrieves individual or batch entries, and deletes data for a given engine and language. It leverages utility functions for path resolution, directory management, and task progress callbacks, and wraps errors in InternalCLARAError to signal repository inconsistencies. Maintainers should note that database updates and file operations are not atomic, and callbacks are used to report progress or errors to calling tasks.",
        "short_summary": "This module manages storage and retrieval of audio metadata and files via Django's ORM. AudioRepositoryORM creates the repository base directory, stores MP3s into engine/language/voice directories, and mirrors those paths in AudioMetadata records. It supports single and batch lookup of entries and bulk deletion of records and associated files by language.",
        "key_responsibilities": [
          "Initialize the audio repository base directory based on configuration and ensure it exists",
          "Add or update AudioMetadata entries for generated or recorded audio, with optional callbacks for progress",
          "Store MP3 files under engine/language/voice directories and return their repository paths",
          "Retrieve audio metadata paths for single or multiple text/context pairs using the Django ORM",
          "Delete metadata and corresponding audio files for a specific engine and language",
          "Provide helper methods to construct engine/language/voice directory paths"
        ],
        "potential_issues": [
          "Database updates and filesystem operations are not transactional; failures could leave metadata and files out of sync",
          "delete_entries_for_language removes the entire language directory, which may delete all voices without additional checks",
          "Error handling is inconsistent; some methods log errors and continue while others raise InternalCLARAError",
          "get_entry_batch relies on items containing a 'canonical_text' key; mismatched input structure could cause missed matches",
          "Imported storage utilities (_s3_storage) are unused; remote storage scenarios are not addressed",
          "No concurrency control when generating unique file names or writing files could lead to race conditions in high-volume use"
        ]
      }
    }
  ],
  "clara_app/clara_cefr.py": [
    {
      "created_at": "2025-12-23T11:43:31.925218+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 955,
        "completion_tokens": 741,
        "total_tokens": 1696,
        "estimated_cost_usd": 0.00860375
      },
      "analysis": {
        "proposed_docstring": "Utility module for estimating the CEFR reading level of a given text by prompting the ChatGPT-4 API. It builds a detailed prompt including official CEFR level descriptors for the specified target language, invokes the chat API via clara_chatgpt4, and returns the model's level guess along with call metadata. Designed to be consumed by Python code, the function isolates the API interaction and response handling.",
        "short_summary": "This module wraps a call to ChatGPT-4 to assess the CEFR reading level of supplied text. It constructs a comprehensive prompt outlining CEFR level definitions in the target language and returns the model's response along with the underlying APICall object. The helper capitalizes the language name and allows optional configuration and callback parameters for the API call.",
        "key_responsibilities": [
          "Provide a single entry point `estimate_cefr_reading_level` to estimate CEFR level for a text and language.",
          "Build a ChatGPT-4 prompt including official CEFR level descriptions and the text to be assessed.",
          "Invoke `clara_chatgpt4.call_chat_gpt4` with optional config and callback, and return the API response with call metadata."
        ],
        "potential_issues": [
          "Uses a mutable default argument `config_info={}`, which can lead to shared state across calls.",
          "No validation or error handling if the API call fails or returns unexpected content beyond the CEFR level.",
          "Simply capitalizes the provided language string, which may not match proper language names or multi-word languages.",
          "Assumes the ChatGPT output will be just the CEFR level; any deviation could break downstream parsing."
        ]
      }
    }
  ],
  "clara_app/clara_chatgpt4.py": [
    {
      "created_at": "2025-12-23T11:44:06.964914+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 6650,
        "completion_tokens": 1298,
        "total_tokens": 7948,
        "estimated_cost_usd": 0.0212925
      },
      "analysis": {
        "proposed_docstring": "Helper module for CLARA's interaction with large language and image models such as OpenAI GPT-4/4o, DALL-E 3/gpt-image-1, and Google Gemini. It provides synchronous wrappers around asynchronous API calls to generate text responses, create or edit images, and interpret images, handling prompt shortening, progress callbacks, response decoding, and cost/duration tracking via APICall objects. The module also extracts JSON content from model responses and persists generated images to disk, integrating configuration and environment-based API key retrieval.",
        "short_summary": "This module wraps OpenAI and Gemini APIs to generate text completions, create or edit images, and interpret images within the CLARA application. It exposes synchronous helper functions that run asynchronous tasks, post heartbeat/progress updates, compute approximate costs, and save returned images. Utilities are provided to shorten overly long prompts, parse JSON from model output, and retrieve API keys from configuration or environment.",
        "key_responsibilities": [
          "Retrieve and normalize API keys for OpenAI, DeepSeek, and Gemini based on configuration and environment variables.",
          "Provide synchronous entry points to asynchronous GPT-4/4o text calls, image generation (DALL-E-3, gpt-image-1), and image interpretation via run_in_executor with heartbeat progress updates.",
          "Shorten image generation prompts when exceeding model limits by invoking GPT-4 itself, and create APICall records with cost and timing via clara_openai utilities.",
          "Save generated images to disk (resizing and decoding from URL or base64) and handle Gemini image responses, as well as parse JSON content from ChatGPT responses."
        ],
        "potential_issues": [
          "get_api_key_and_provider_for_config references provider_for_model/openai/deep_seek which are not imported in this module and may raise NameError at runtime.",
          "Use of asyncio.run in call_* wrappers can fail if invoked inside an existing event loop (e.g., in ASGI contexts).",
          "Prompt shortening helpers pass hardcoded empty config_info instead of the caller-provided config_info, possibly ignoring custom model or key settings.",
          "The gpt-image-1 editing logic and element_files handling may not match OpenAI's expected API contract, risking errors, and error handling is minimal.",
          "Gemini image bytes handling assumes base64-encoded content; incorrect decoding could occur if the API returns raw bytes.",
          "Environment/config API key validation is minimal; missing or malformed keys will surface as late runtime errors."
        ]
      }
    }
  ],
  "clara_app/clara_chinese.py": [
    {
      "created_at": "2025-12-23T11:44:27.218472+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1659,
        "completion_tokens": 1084,
        "total_tokens": 2743,
        "estimated_cost_usd": 0.012913749999999998
      },
      "analysis": {
        "proposed_docstring": "Utilities for handling Chinese text within C-LARA, including segmentation with Jieba and pinyin annotation with pypinyin. The module provides helpers to split input into sentences and tokens, add end-of-segment markers, and convert segmented text into annotated Text/Page/Segment structures. It also offers a workflow to internalize a segmented string, decorate word content elements with pinyin, and render back out to text. Supporting predicates for Chinese punctuation and language checks are included.",
        "short_summary": "This module offers helper functions for Chinese text segmentation and pinyin annotation. It wraps Jieba to segment input strings into tokens and marks sentence boundaries with separators. It also uses pypinyin to annotate word content elements in an internal Text structure and render pinyin-tagged output.",
        "key_responsibilities": [
          "Determine whether a language identifier corresponds to Chinese.",
          "Segment Chinese text into sentences and tokens using Jieba, consolidating punctuation and marking segment boundaries.",
          "Apply tokenization results back onto the original string with appropriate separators and end-of-segment markers.",
          "Internalize segmented text into Text/Page/Segment/ContentElement objects and annotate words with pinyin using pypinyin.",
          "Provide helper predicates for identifying Chinese punctuation, sentence-final marks, and quote characters."
        ],
        "potential_issues": [
          "apply_tokenise_result_to_string uses string.find to locate tokens in the original text, which may fail or misalign when tokens repeat or differ from the source; it only emits a warning and breaks out.",
          "Whitespace is treated as punctuation in punctuation_token, which could lead to unexpected consolidation of spaces with punctuation tokens.",
          "pinyin_tag_text_using_pypinyin hard-codes the L2 language as 'mandarin' and L1 as 'irrelevant', ignoring any actual language context passed in.",
          "Content elements are annotated in place; if reused elsewhere, the pinyin annotation may have side effects.",
          "Segmentation relies on jieba output matching the original string exactly; differences in tokenization (e.g. around punctuation) could lead to misplaced separators."
        ]
      }
    }
  ],
  "clara_app/clara_classes.py": [
    {
      "created_at": "2025-12-23T11:44:46.414627+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 11957,
        "completion_tokens": 1017,
        "total_tokens": 12974,
        "estimated_cost_usd": 0.02511625
      },
      "analysis": {
        "proposed_docstring": "Utility classes and helpers for representing and rendering C‑LARA texts. Defines the core ContentElement/Segment/Page/Text hierarchy with methods to produce annotated text views and serialize to and from JSON. Also includes ancillary types for images, API call logging, diff elements, escaping helpers, and a set of custom exception types used elsewhere in the project.",
        "short_summary": "This module implements the core in‑memory model for C‑LARA texts, including content elements, segments, pages, and full texts with language metadata. It provides rendering routines for various annotation views, JSON serialization/deserialization, and convenience accessors. Additional classes cover image metadata, API call records, diff elements, and custom exceptions, alongside escaping utilities.",
        "key_responsibilities": [
          "Model text structure as ContentElement, Segment, Page, and Text objects with annotations and counts",
          "Render text in multiple annotation modes and produce concatenated or segmented representations",
          "Serialize and deserialize text/page structures and related metadata to and from JSON",
          "Represent ancillary artifacts such as images, API calls, and diff elements for comparison",
          "Provide escaping utilities for annotated text and helpers for punctuation detection"
        ],
        "potential_issues": [
          "Custom exception classes do not call super().__init__, so Exception.message may not behave as expected",
          "Page.to_text emits <page> tags without closing tags and wraps exceptions by printing to stdout, which may be undesirable in production",
          "escape_special_chars returns '-' for any falsy non-empty input (e.g., None), which may surprise callers expecting an empty string",
          "string_is_only_punctuation_spaces_and_separators relies on the third-party 'regex' module; ensure it is installed and behaves as intended with Unicode punctuation"
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images.py": [
    {
      "created_at": "2025-12-23T11:45:10.225859+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 25058,
        "completion_tokens": 1199,
        "total_tokens": 26257,
        "estimated_cost_usd": 0.043312500000000004
      },
      "analysis": {
        "proposed_docstring": "Utilities for driving the \"coherent images\" pipeline: expanding style, element, and page descriptions with LLM prompts, generating and evaluating images via the ChatGPT API, selecting best candidates, and writing out project artifacts and cost accounting. This module orchestrates asynchronous generation of style exemplars, named elements, and per-page illustrations with contextual prompts, handles community and simple-Clara requests for variants or uploaded images, and produces an HTML overview of a project's outputs. It interacts heavily with project-specific metadata (advice, background, story text), prompt templates, cost tracking, and alternate image management, and provides helper workflows to interpret and evaluate images or correct prompts after policy failures.",
        "short_summary": "This module coordinates asynchronous generation of coherent story images for styles, elements, and pages using ChatGPT-based prompts. It expands descriptions, generates and rates images, selects best outputs, maintains cost files and alternate image metadata, and can process community or simple-Clara requests and uploaded images. It also produces an HTML overview of a project's current images, descriptions, and evaluations.",
        "key_responsibilities": [
          "Expand style, element, and page descriptions via prompt templates and ChatGPT calls, then generate, interpret, and evaluate images for each.",
          "Select representative or best-rated descriptions and images, update alternate_images metadata, and write cost and error files to the project structure.",
          "Handle community and simple-Clara request workflows (advice application, variants, uploaded images) and manage element/page/style lifecycle (add/delete).",
          "Determine relevant context for page generation (prior pages and elements), manage retries and content policy corrections, and support different image generation backends.",
          "Render an HTML overview of a project's background, style, elements, pages, images, alternates, and evaluation summaries."
        ],
        "potential_issues": [
          "Variable and scope errors in correction logic: correct_expanded_description_after_content_policy_failure references undefined variables (page_text, project_dir, description_version_number) and may not function.",
          "In generate_and_rate_page_images recursive retry, the subsequent call is not awaited and returns a coroutine, likely breaking error correction logic.",
          "In generate_and_rate_page_image, evaluation_cost_dict is combined even when undefined (no_ai_checking branch uses evaluation_cost_dic with a different name), which may raise exceptions.",
          "Error handling is often limited to writing error.txt; some branches (e.g., content policy correction, interpretation/evaluation failures) may leave stale or partial files and miss updates.",
          "Extensive async usage with concurrent tasks may mask exceptions; cost dict merging and directory existence checks could race if run in parallel without safeguards."
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_advice.py": [
    {
      "created_at": "2025-12-23T11:45:26.551086+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1402,
        "completion_tokens": 973,
        "total_tokens": 2375,
        "estimated_cost_usd": 0.011482500000000001
      },
      "analysis": {
        "proposed_docstring": "Utilities for managing per-project advice text used in coherent image generation, including background information, style descriptions, and page- or element-specific guidance. This module reads and writes advice files in a project-specific directory structure, validates requested elements or pages against known project data, and assembles combined advice snippets for consumption elsewhere. It wraps lower-level file operations provided by clara_coherent_images_utils and clara_utils to ensure directories exist and paths are constructed consistently.",
        "short_summary": "This module provides helper functions to read and write advice text associated with a coherent images project. It covers background and style descriptions as well as per-element and per-page advice, mapping them to files under a project's directory structure. Functions validate known elements/pages and can assemble combined background and page advice strings.",
        "key_responsibilities": [
          "Read and write project-level background advice and style description text files",
          "Manage per-element and per-page advice by constructing appropriate directories and filenames",
          "Validate requested element names and page numbers against project data when possible",
          "Assemble combined background and page advice for a given page number"
        ],
        "potential_issues": [
          "Validation of page numbers is commented out in get_page_advice/set_page_advice, so invalid pages may be accepted silently",
          "get_background_advice and get_style_advice swallow all exceptions and return empty strings, potentially hiding file system or encoding errors",
          "check_valid_element_name relies on get_all_element_texts; mismatches between element text and derived element name could cause path issues",
          "File system errors or permission issues during directory creation and file writes are not surfaced beyond potential exceptions"
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_alternate.py": [
    {
      "created_at": "2025-12-23T11:46:43.107588+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3376,
        "completion_tokens": 2372,
        "total_tokens": 5748,
        "estimated_cost_usd": 0.02794
      },
      "analysis": {
        "proposed_docstring": "Utilities for enumerating and managing alternate image variants within a coherent images project. This module scans description/image directories to generate an alternate_images.json manifest, gathers style, element and page images along with advice data for use elsewhere, and exposes helpers to promote a chosen alternate's assets to the primary content files. It also provides simple mechanisms to mark alternates as hidden and to resolve alternate IDs for given descriptions, with optional task update callbacks during long-running operations.",
        "short_summary": "This module supports handling alternate images in coherent image projects by scanning content directories and producing metadata. It builds a project-wide image dictionary that includes background, style, elements and pages with associated advice and alternate listings. It also allows promoting alternate assets to the main content and marking alternates as hidden.",
        "key_responsibilities": [
          "Generate and write alternate_images.json by inspecting description_v*/image_v* directories and recording available alternates with relative paths and hidden status.",
          "Promote a selected alternate image or description by copying its files into the top-level content directory.",
          "Assemble a comprehensive images dictionary for a project, including background/style/element/page advice and available alternates for each.",
          "Mark or unmark alternates as hidden via marker files and look up alternate IDs by description index."
        ],
        "potential_issues": [
          "The force_remake argument to get_alternate_images_json is ignored; a hardcoded FORCE_REMAKE=True forces regeneration on every call.",
          "Asynchronous functions perform synchronous filesystem operations and globbing, which may block the event loop.",
          "Hidden marker creation/removal and promotion helpers assume directory structures exist and may fail or raise if they do not.",
          "promote_alternate_element_description has no explicit return on failure and does not copy elements.json, which may lead to inconsistent state."
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_community_feedback.py": [
    {
      "created_at": "2025-12-23T11:47:05.600108+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 7525,
        "completion_tokens": 1015,
        "total_tokens": 8540,
        "estimated_cost_usd": 0.01955625
      },
      "analysis": {
        "proposed_docstring": "Utilities for managing and reviewing community feedback on coherent images, elements, and style within a project. This module loads and persists per‑page/element/style feedback JSON files, aggregates votes, advice, variant requests, and computes preferred images or descriptions based on human and AI scoring. It provides helper functions to present condensed overview and description information for content manager review, register new votes or advice, update AI votes by scoring generated images asynchronously, and query or modify outstanding feedback requests. All operations interact directly with the filesystem rather than Django models or templates, and rely on supporting utilities to read project content and compute AI scores.",
        "short_summary": "This module encapsulates logic for reading, writing, and aggregating community feedback on generated images, elements, and style in a project. It supports registering votes, advice, and variant requests, computing preferred images/descriptions, and updating AI votes based on automated scoring of image directories. Helper functions assemble feedback for content manager review and manage outstanding requests. Data is stored in JSON files within the project directory and accessed via utility functions, with asynchronous image enumeration invoked synchronously via asyncio.run.",
        "key_responsibilities": [
          "Load and save community feedback JSON files for pages, elements, and style, including votes, advice, comments, and variant requests.",
          "Register and update votes, advice, and variant requests, optionally overriding placeholder AI votes and removing them when AI checking is disabled.",
          "Gather overview and description-level feedback data for content manager review, including vote counts and preferred image/description determination.",
          "Compute and persist preferred images or descriptions based on net human/AI votes and update AI votes by scoring generated image directories with async helpers.",
          "List, set status on, or remove outstanding content manager feedback requests across project pages."
        ],
        "potential_issues": [
          "Repeated use of asyncio.run to invoke async image enumeration may block or conflict if called from an existing event loop.",
          "Feedback updates read and rewrite plain JSON files without locking, so concurrent writes could corrupt data or lose changes.",
          "Advice indices are regenerated and saved on load, which may shift identifiers and affect status/removal if list order changes.",
          "AI vote override logic only updates existing AI votes; if no AI vote exists it will not be created or overridden.",
          "preferred_page_image_is_uploaded swallows exceptions and may silently return False, making debugging difficult."
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_evaluate_image.py": [
    {
      "created_at": "2025-12-23T11:47:43.405074+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3325,
        "completion_tokens": 1236,
        "total_tokens": 4561,
        "estimated_cost_usd": 0.01651625
      },
      "analysis": {
        "proposed_docstring": "Asynchronous helper routines for interpreting and evaluating generated page images against story text using ChatGPT4 prompt templates. The module builds prompts for various subtasks (describing elements, relationships, style, and overall fit), invokes the appropriate GPT-4 image or text endpoints with retry and cost accounting, and combines results for multi-question strategies. It also provides a wrapper to assess how well an image matches a page's narrative content. Errors and accumulated API costs are surfaced alongside responses for further handling.",
        "short_summary": "This module orchestrates GPT-4 image interpretation and evaluation tasks for coherent image generation. It builds prompts from templates and story/page context, calls ChatGPT4 APIs asynchronously with retry logic, and aggregates descriptions and relationship analyses for complex inquiries. It also offers a function to evaluate how well an image fits the accompanying text.",
        "key_responsibilities": [
          "Construct prompts for element, page, and fit evaluation based on story data, page text, and language settings",
          "Invoke GPT-4 image and text interpretation APIs asynchronously with configurable retries and cost tracking",
          "Identify elements present in an image, describe them and their relationships, and combine multi-question results into comprehensive descriptions",
          "Evaluate the alignment between an image's content and a page's expanded description or narrative"
        ],
        "potential_issues": [
          "Some functions return inconsistent tuples on failure (e.g. missing errors or cost entries), which may break callers expecting three values",
          "The check in get_important_pairs_in_image uses the first element twice, likely a typo that should validate both elements in each pair",
          "interpret_image_with_prompt_multiple_questions accumulates errors from the wrong variable and may not include later errors",
          "expanded_description is unused in interpret_element_image_with_prompt, which might be an oversight",
          "Many imported utilities are unused; ensure only needed functions are kept or used to avoid confusion"
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_evaluate_prompts.py": [
    {
      "created_at": "2025-12-23T11:47:59.033837+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3810,
        "completion_tokens": 1177,
        "total_tokens": 4987,
        "estimated_cost_usd": 0.016532500000000002
      },
      "analysis": {
        "proposed_docstring": "Utility module for evaluating how well generated images match story text, combining human ratings with automated GPT-based interpretations and scoring. It provides an interactive CLI to collect human evaluations across a project’s page/image hierarchy, async workflows to interpret images and assess their fit using specified prompt templates, and tools to analyze agreement between human and AI scores. Additional helpers produce correlation statistics and render HTML reports summarizing evaluations and associated cost information.",
        "short_summary": "This module orchestrates human and AI evaluation of generated images against story text. It lets users rate images interactively, runs async GPT-powered interpretation and fit scoring for those images, and augments human evaluations with AI results. It also computes agreement metrics and can generate an HTML report of the evaluations.",
        "key_responsibilities": [
          "Iterate over project pages and images to collect human scores and comments, persisting them to JSON with resume support.",
          "Asynchronously interpret images and evaluate their fit to expanded descriptions using configured GPT prompt IDs, augmenting human evaluations with AI results and cost tracking.",
          "Analyze agreement between human and AI scores via correlation metrics, mean error, kappa, and confusion matrices, with optional plotting.",
          "Render augmented evaluation data into a templated HTML report for review."
        ],
        "potential_issues": [
          "Correlation analysis filters out evaluations where fit_score is 0 because of truthy checks, potentially skewing metrics.",
          "The interactive human_evaluation uses PIL image.show() and input(), which may block or misbehave in headless or non-interactive environments.",
          "Asynchronous gather of many interpret/evaluate tasks may overwhelm external APIs or hit rate limits without throttling.",
          "Matplotlib plt.show() will block execution and requires a display backend; running in a non-GUI environment could fail.",
          "HTML report generation assumes image paths are accessible from the filesystem where the report is viewed; relative paths may break if moved."
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_export.py": [
    {
      "created_at": "2025-12-23T11:48:24.478765+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1214,
        "completion_tokens": 1434,
        "total_tokens": 2648,
        "estimated_cost_usd": 0.0158575
      },
      "analysis": {
        "proposed_docstring": "Utilities to collect element and page images for a project, apply a watermark, and bundle them into an in-memory ZIP archive for download. It relies on Clara image utilities to locate project image paths, uses PIL to composite a standard or uploaded-image watermark onto each image, and provides a helper to decide whether an image stems from an uploaded page. The module does not expose a view itself but can be used by views to generate raw ZIP bytes for responses.",
        "short_summary": "This module builds an in-memory ZIP archive of all element and page images for a given project, overlaying a watermark on each image before packaging. It distinguishes uploaded page images to optionally use a different watermark. Helper functions handle watermark compositing and identifying uploaded images based on path structure.",
        "key_responsibilities": [
          "Gather all element and relative page image paths for a project using coherent image utilities",
          "Load watermark images and overlay them onto base images via PIL before export",
          "Determine whether a given image path corresponds to an uploaded page image",
          "Assemble watermarked images into an in-memory ZIP archive for download"
        ],
        "potential_issues": [
          "Exceptions during image processing are silently swallowed, potentially skipping files without logging",
          "image_relpath_is_uploaded assumes a specific path structure and may index incorrectly on unexpected paths",
          "Watermark file paths are hard-coded and not checked for existence before use",
          "All images are converted to JPEG with RGB, which may discard transparency or introduce quality loss",
          "Potential duplication of images in the ZIP if get_all_element_images and get_all_relative_page_images overlap",
          "Repeated calls to image_relpath_is_uploaded for the same path could be avoided for efficiency"
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_prompt_templates.py": [
    {
      "created_at": "2025-12-23T11:49:10.266703+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 10823,
        "completion_tokens": 2107,
        "total_tokens": 12930,
        "estimated_cost_usd": 0.03459875
      },
      "analysis": {
        "proposed_docstring": "Collection of prompt template strings used throughout the coherent image generation workflow, covering style and element specification, page descriptions, and evaluation tasks. Provides a single entry point, get_prompt_template, to retrieve a named template by type, and enumerates all supported template types. Templates are intended to be formatted elsewhere with contextual values (e.g. story text, style descriptions, language, and length constraints).",
        "short_summary": "Defines a catalog of prompt templates for guiding image generation, interpretation, and evaluation in the coherent images pipeline. Exposes get_prompt_template to fetch a template by type and identifier from the pre-defined dictionaries. Templates cover style descriptions, element naming and descriptions, page-level prompts, corrections, and various evaluation scenarios.",
        "key_responsibilities": [
          "Maintain a list of known prompt template types and corresponding template dictionaries for style, element, and page workflows.",
          "Provide get_prompt_template to validate template types and retrieve a specific template by identifier.",
          "Offer pre-written prompt bodies with placeholders to be populated by other parts of the system when interacting with image-generation or evaluation models."
        ],
        "potential_issues": [
          "known_prompt_template_types and the lookup logic must be manually kept in sync with the defined template dictionaries; adding new templates requires updating both.",
          "Several templates are declared as f-strings with escaped braces and nested placeholders; misuse of formatting could lead to malformed prompts or double formatting.",
          "The long if/elif chain in get_prompt_template is brittle and may be error-prone if extended.",
          "The get_relevant_elements_prompt_templates default string contains a stray \"[ \" line that could confuse downstream JSON parsing expectations.",
          "Config-derived max length settings are commented out, so length constraints rely on external formatting without explicit enforcement here."
        ]
      }
    }
  ],
  "clara_app/clara_coherent_images_utils.py": [
    {
      "created_at": "2025-12-23T11:49:34.122705+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 8237,
        "completion_tokens": 785,
        "total_tokens": 9022,
        "estimated_cost_usd": 0.01814625
      },
      "analysis": {
        "proposed_docstring": "Utility module for managing coherent image generation projects in C-LARA. It defines helpers to read and validate project parameters, construct task-specific configuration for GPT/text/image generation calls, and organise filesystem structures for styles, elements and pages. It also provides routines for scoring and selecting representative images, tracking costs, and reading/writing story and element metadata, including asynchronous wrappers for OpenAI image and interpretation APIs. Path utilities and convenience accessors simplify interacting with project directories and files.",
        "short_summary": "This module contains helper functions for the C-LARA coherent images workflow. It manages project parameters, directory structures, and metadata for styles, elements, and pages, and orchestrates calls to GPT-based text/image generation and interpretation APIs. It also includes scoring, cost aggregation, and file/path handling utilities for generated content.",
        "key_responsibilities": [
          "Read, write, validate, and default project parameter JSON files and derive task-specific parameter subsets for styles, elements, and pages.",
          "Manage project filesystem structure: building pathnames, creating/removing directories, and storing/retrieving story data, descriptions, images, and evaluations.",
          "Score and select representative or best images and record associated interpretation/evaluation metadata, with content policy violation checks.",
          "Provide async wrappers to call chat/image generation and image interpretation APIs using configured GPT/image models.",
          "Aggregate and persist cost information for API calls and assist with path sanitisation for project-relative file access."
        ],
        "potential_issues": [
          "The module redefines ImageGenerationError at the end while also importing it from clara_classes, which could cause confusion about which class is used elsewhere.",
          "get_max_image_prompt_length logs an incorrect variable and may return None if an unexpected image_model is provided or config lacks the expected keys.",
          "Several functions catch broad exceptions and silently fall back to defaults (e.g., get_project_params, get_story_data), potentially masking errors in project state.",
          "Path sanitisation and manipulation rely on conventions; passing unexpected absolute paths could raise ValueError or bypass intended checks.",
          "print_cost_dict mutates the passed cost_dict by adding a 'total' key, which may be unintended side effects for callers."
        ]
      }
    }
  ],
  "clara_app/clara_community.py": [
    {
      "created_at": "2025-12-23T11:49:52.071919+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 479,
        "completion_tokens": 1034,
        "total_tokens": 1513,
        "estimated_cost_usd": 0.01093875
      },
      "analysis": {
        "proposed_docstring": "Helper functions for associating CLARA projects with language communities and checking user membership roles. Provides utilities to assign a project to a community with a language consistency check, determine whether a user belongs to a project's community, and verify if a user is a coordinator of that community, using Django's ORM and get_object_or_404 to fetch model instances. Intended to support view logic around community access and coordination.",
        "short_summary": "This module offers utility functions around CLARA projects and their associated communities. It allows assigning a project to a community with a language match check and checking whether a given user belongs to or coordinates the project's community. The helpers fetch required models via get_object_or_404 and rely on community membership records.",
        "key_responsibilities": [
          "Assign a CLARAProject to a Community, ensuring the project's L2 matches the community's language before saving.",
          "Check whether a given user is a member of the community associated with a specified project.",
          "Determine if a user holds the coordinator role within a project's community."
        ],
        "potential_issues": [
          "ValidationError is referenced but not imported, which will cause a NameError when a language mismatch is encountered.",
          "CommunityMembership is used in membership checks but is not imported from models, leading to NameError.",
          "These helpers raise Http404 via get_object_or_404; callers must be prepared to handle that in non-view contexts.",
          "No authentication or permission checks are performed; callers must ensure the user is appropriate for the queried project."
        ]
      }
    }
  ],
  "clara_app/clara_concordance_annotator.py": [
    {
      "created_at": "2025-12-23T11:50:13.235964+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 796,
        "completion_tokens": 1252,
        "total_tokens": 2048,
        "estimated_cost_usd": 0.013515
      },
      "analysis": {
        "proposed_docstring": "Module providing a ConcordanceAnnotator for enriching Text-like objects with concordance information. It iterates through pages and segments, assigning page numbers and unique segment identifiers, and aggregates lemma or phonetic keys with frequency counts and segment references, including words found in transformed image segments. The computed concordance is attached to the text's annotations for downstream use.",
        "short_summary": "Defines a ConcordanceAnnotator that walks through a text's pages and segments to build concordance data. It tags segments with page and unique IDs, collects lemma or phonetic keys from word elements (including transformed image segments), and computes frequencies adjusted for multi-word expressions. The resulting concordance is stored on the text annotations.",
        "key_responsibilities": [
          "Assign page numbers and unique segment identifiers to each segment in the text.",
          "Aggregate concordance entries keyed by lemma or phonetic annotation from word elements across segments and transformed image segments.",
          "Compute frequency counts, adjusting for multi-word expressions, and attach segment references and frequencies to the text's annotations."
        ],
        "potential_issues": [
          "Frequency counts for multi-word expressions are adjusted by fractional increments and then rounded, potentially losing precision.",
          "Assumes text.pages, page.segments, and segment.content_elements are present and well-formed; missing attributes could raise errors.",
          "The code accesses element.content['transformed_segments'] for images without comprehensive checks, which may fail if the structure differs.",
          "Existing segment annotations for 'page_number' or 'segment_uid' will be overwritten when annotate_text is called.",
          "The imported 're' module is unused, indicating possible leftover or incomplete functionality."
        ]
      }
    }
  ],
  "clara_app/clara_conventional_tagging.py": [
    {
      "created_at": "2025-12-23T11:50:34.171078+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3584,
        "completion_tokens": 944,
        "total_tokens": 4528,
        "estimated_cost_usd": 0.01392
      },
      "analysis": {
        "proposed_docstring": "Utility functions for running TreeTagger over internalised CLARA texts and populating POS/lemma annotations. Provides helpers to generate trivially tagged or TreeTagger-tagged versions of segmented text, invoking the external TreeTagger binaries via cygwin bash and temporary files. Handles alignment of tagged output back onto internal content elements and conversion of tags to Universal Dependencies v2 where supported. Includes language support checks and invocation templates for various languages, plus a simple test harness.",
        "short_summary": "This module wraps the external TreeTagger tool to annotate text with parts of speech and lemmas. It can internalize segmented text, run tagging, align the results back to content elements, and convert tagsets. It also supports trivial tagging for test purposes and exposes language-specific invocation templates.",
        "key_responsibilities": [
          "Internalize segmented text and apply trivial or TreeTagger-based POS/lemma annotations to content elements.",
          "Create and manage temporary files for TreeTagger input/output and invoke the appropriate TreeTagger command via bash.",
          "Parse TreeTagger output into structured tuples and align tags back to the original sequence of words using difflib.",
          "Maintain language-specific TreeTagger command templates and check for supported languages and installed parameter files."
        ],
        "potential_issues": [
          "Sequence alignment assumes exact tokenization; any mismatch between internal tokens and TreeTagger output leaves annotations as NO_ANNOTATION.",
          "modify_template_for_preprocessed_text raises a TreeTaggerError with a literal \"template\" string instead of the actual template content, which hampers debugging.",
          "Parsing TreeTagger output expects each non-empty line to contain exactly three tab-separated fields; differing output formats will raise errors.",
          "External dependencies on environment variables ($CLARA, $TREETAGGER) and config paths (bash executable) must be correctly set, otherwise invocation will fail.",
          "Unsupported languages or missing parameter files are only checked via templates and file existence; misconfigured installations may not be detected until runtime."
        ]
      }
    }
  ],
  "clara_app/clara_correct_syntax.py": [
    {
      "created_at": "2025-12-23T11:50:46.046261+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2244,
        "completion_tokens": 631,
        "total_tokens": 2875,
        "estimated_cost_usd": 0.009115
      },
      "analysis": {
        "proposed_docstring": "Utility functions to validate and auto-correct CLARA annotated text using ChatGPT-4. This module walks over page- and segment-delimited strings, checks whether segment markup is well-formed, and if not repeatedly prompts ChatGPT-4 with tailored instructions to fix hashtags, slashes, or vertical bar annotations. It reports progress via task callbacks, validates corrected text via the internal parser, and builds prompts appropriate to different annotation types.",
        "short_summary": "Provides helpers to validate and correct annotated text segments for various markup types by leveraging ChatGPT-4. It splits incoming text into pages and segments, parses them to detect malformed annotations, and iteratively calls the ChatGPT API to propose fixes, updating task status along the way.",
        "key_responsibilities": [
          "Expose `correct_syntax_in_string` and `correct_syntax_in_segment` to iterate over page/segment-delimited text, parse annotations, and trigger corrections as needed.",
          "Construct prompt strings tailored to specific annotation types such as segmented, gloss, lemma, translated, and multi-word expressions.",
          "Manage retry logic and API call aggregation when invoking `call_chat_gpt4`, validating responses with `parse_segment_text`, and posting task updates via callbacks."
        ],
        "potential_issues": [
          "Uses a mutable default argument `config_info={}` which could lead to shared state between calls.",
          "References `traceback.format_exc()` in an exception handler without importing the traceback module, causing a NameError on error paths.",
          "Catches all exceptions broadly, which may mask unexpected errors or make debugging difficult.",
          "Relies on `parse_segment_text` to throw exceptions for malformed input; if it returns falsy without raising, corrections will never be attempted."
        ]
      }
    }
  ],
  "clara_app/clara_create_annotations.py": [
    {
      "created_at": "2025-12-23T11:51:16.230133+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 24463,
        "completion_tokens": 1346,
        "total_tokens": 25809,
        "estimated_cost_usd": 0.04403875
      },
      "analysis": {
        "proposed_docstring": "Module providing the GPT‑4 driven annotation pipeline for CLARA texts. It orchestrates two-phase segmentation, glossing, lemmatization, pinyin, MWE tagging and translation by building prompt templates, dispatching asynchronous calls to ChatGPT, parsing and repairing responses, and merging annotations back into internalized text structures. The functions expose high-level entry points to generate or improve annotated versions of texts, handle chunking and parallelization, and post task updates via callbacks. It also includes utilities for validating and normalizing pre-segmentation, handling MWEs, and constructing example-based prompts from template repositories.",
        "short_summary": "This module coordinates GPT-4 based annotation of texts, including segmentation, glossing, lemmatization, pinyin, MWE tagging, and translation. It builds prompts from templates, chunks work for async calls to GPT-4, parses and repairs model responses, and merges annotations back into internal content structures. The code includes utilities for pre-segmentation validation, handling MWEs, and template/example generation.",
        "key_responsibilities": [
          "Provide high-level functions to generate or improve segmented, glossed, tagged, translated, pinyin, and MWE-tagged versions of texts.",
          "Construct prompt strings from configurable templates and examples, including handling of MWEs and context, before sending to GPT-4.",
          "Manage asynchronous batching of annotation requests and updates, including retries, task progress callbacks, and result aggregation.",
          "Parse, validate, and repair GPT-4 responses for different processing phases, enforcing token alignment and MWE consistency, then merge back into internal text representations.",
          "Utility routines for pre-segmentation sanitation/validation, chunking elements by segment, and converting between simplified and internalized annotation formats."
        ],
        "potential_issues": [
          "Several functions reference undefined variables (e.g. improve_morphology_in_segmented_version uses segmented_text and l1_language that are not defined; improve_pinyin_tagged_version uses tagged_text instead of pinyin_tagged_text).",
          "unsimplify_element has a segmentation branch that refers to an undefined variable 'content' instead of the provided values, likely causing errors.",
          "morphology_prompt references annotate_or_improve but does not accept it as a parameter, suggesting a bug in prompt construction.",
          "call_process_annotations_async returns an asyncio.Future when an event loop is already running; callers expecting a tuple may get a coroutine, leading to runtime errors in async contexts.",
          "Segmentation improvement is explicitly unsupported and raises ValueError; callers may not expect this limitation.",
          "There is risk of mismatched length or content between simplified elements and GPT responses; although some repairs exist, edge cases may still raise ChatGPTError."
        ]
      }
    }
  ],
  "clara_app/clara_create_story.py": [
    {
      "created_at": "2025-12-23T11:51:34.334235+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 725,
        "completion_tokens": 810,
        "total_tokens": 1535,
        "estimated_cost_usd": 0.00900625
      },
      "analysis": {
        "proposed_docstring": "Utilities for generating and refining short language texts via Clara's ChatGPT4 integration. This module builds language-specific prompts and invokes clara_chatgpt4.call_chat_gpt4 to either create a quirky news story for intermediate learners or to correct and improve an existing text. Both workflows return the generated text along with the underlying API call object for further inspection or logging.",
        "short_summary": "This helper module encapsulates prompt construction for Clara's ChatGPT4 to generate or improve texts in a specified language. It exposes functions to produce a short news story with a default or custom prompt and to rewrite an existing passage with corrections or guided improvements. Each function delegates to clara_chatgpt4.call_chat_gpt4 and returns the response alongside the API call metadata.",
        "key_responsibilities": [
          "Construct prompts for generating short, quirky news stories in a target language with optional custom instructions.",
          "Construct prompts for correcting or rewriting an existing text in a target language, with optional improvement advice.",
          "Invoke clara_chatgpt4.call_chat_gpt4 with the composed prompt, passing through configuration and callback parameters.",
          "Return the generated text and the associated API call object(s) to the caller."
        ],
        "potential_issues": [
          "Uses a mutable default argument (config_info={}) which can lead to shared state across calls.",
          "Lacks error handling around clara_chatgpt4.call_chat_gpt4 failures or unexpected return structures.",
          "Assumes the API call object has a .response attribute; changes in clara_chatgpt4 could break this contract.",
          "Input parameters like language and prompts are not sanitized, which could affect prompt content or model behavior."
        ]
      }
    }
  ],
  "clara_app/clara_create_title.py": [
    {
      "created_at": "2025-12-23T11:51:46.263253+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 589,
        "completion_tokens": 711,
        "total_tokens": 1300,
        "estimated_cost_usd": 0.00784625
      },
      "analysis": {
        "proposed_docstring": "Helper functions for generating or refining titles for L2 texts using ChatGPT-4. Builds prompts incorporating the target language and given text, delegates to clara_chatgpt4.call_chat_gpt4, and returns the model's response alongside the underlying APICall objects. Intended to be used by scripts that consume the raw title string without additional formatting.",
        "short_summary": "This module wraps ChatGPT-4 calls to create or improve titles for a given text in a specified language. It constructs plain prompts based on the text and target language, calls clara_chatgpt4, and returns the generated title along with the API call metadata.",
        "key_responsibilities": [
          "Construct prompts to ask ChatGPT-4 to generate or enhance a title in the target language",
          "Invoke clara_chatgpt4.call_chat_gpt4 with optional configuration and callback",
          "Return the model's title response together with the associated APICall instance for logging or tracking"
        ],
        "potential_issues": [
          "Module-level docstring mentions CEFR level estimation, which does not match the implemented title generation",
          "Uses a mutable default argument for config_info, which can lead to unexpected state sharing",
          "Capitalizing l2_language may not be appropriate for all language names or locales",
          "No validation or error handling around API failures or malformed inputs; returns whatever the model outputs",
          "Relies on ChatGPT to avoid quotes/comments as instructed in the prompt, which may not always be respected"
        ]
      }
    }
  ],
  "clara_app/clara_dall_e_3_image.py": [
    {
      "created_at": "2025-12-23T11:52:07.960839+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3563,
        "completion_tokens": 1510,
        "total_tokens": 5073,
        "estimated_cost_usd": 0.01955375
      },
      "analysis": {
        "proposed_docstring": "Utility helpers for creating and attaching DALL-E 3 generated images to CLARA projects. The module builds prompts from project text or user-supplied style guidance, invokes OpenAI image generation and interpretation APIs, and persists the resulting images and metadata into the project's internal representation. It reports progress via task update callbacks and records API usage for cost tracking, cleaning up temporary files along the way. These functions are intended to be run from background tasks or other workflows that need to enrich project content with AI-generated imagery.",
        "short_summary": "Provides helper functions to generate DALL-E 3 images for a project's full text or to define a visual style. It composes appropriate prompts, calls GPT-4 image generation/interpretation, and stores the resulting files and descriptions in the project's internal storage. Progress and API usage are reported through callbacks and stored for later accounting.",
        "key_responsibilities": [
          "Generate a whole-text illustration by building a prompt from the project's plain text and optional advice and invoking the GPT-4 image API",
          "Create a style-defining image from a user prompt and derive a detailed style description via GPT-4 image interpretation",
          "Attach generated images, along with associated metadata such as page, position, style description, and user prompt, to a CLARA project via CLARAProjectInternal",
          "Report task progress/status via post_task_update callbacks and log API calls for cost tracking"
        ],
        "potential_issues": [
          "temp_dir is defined inside the try block; if an exception occurs before its assignment (e.g. get_object_or_404 raising), the finally clause will raise an UnboundLocalError when referencing temp_dir",
          "Broad Exception catching swallows specific errors like Http404 or validation issues, returning False instead of propagating, which may obscure failures to callers",
          "Minor prompt formatting typo with an extra parenthesis in the non-English text warning may affect the clarity of the prompt",
          "Temporary directories are removed in finally, but if temp_dir removal fails or is not created, temporary files may be left behind"
        ]
      }
    }
  ],
  "clara_app/clara_dependencies.py": [
    {
      "created_at": "2025-12-23T11:52:37.303081+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4254,
        "completion_tokens": 1403,
        "total_tokens": 5657,
        "estimated_cost_usd": 0.0193475
      },
      "analysis": {
        "proposed_docstring": "Utility module that models C-LARA processing phases, their dependencies and freshness. It encapsulates logic for determining which processing outputs are relevant, computing transitive dependencies, querying timestamps from project files, images, audio metadata and related database records, and assessing whether each phase is up to date. Helper functions convert and compare timestamps, allowing callers to inspect ages and debug dependency status across phases.",
        "short_summary": "This module defines CLARADependencies, a helper for tracking C-LARA processing phases and whether their outputs are up to date. It maps immediate and transitive dependencies, filters out irrelevant phases based on language and image versioning, and fetches timestamps for files and records associated with each phase. Utility functions compare timestamps and compute ages to support dependency status evaluation.",
        "key_responsibilities": [
          "Maintain an ordered list of processing phases with their immediate dependencies and determine transitive dependencies.",
          "Filter out irrelevant phases (e.g. pinyin for non-Chinese, legacy or v2 image generation) when evaluating dependencies.",
          "Fetch modification timestamps for text versions, generated images, rendered HTML, audio metadata, and related database objects.",
          "Compute latest dependency timestamps and determine whether each phase is up to date relative to its dependencies, with optional phases handled specially.",
          "Provide utilities to convert and compare timestamps, find the latest timestamp in a set, and calculate age for debugging."
        ],
        "potential_issues": [
          "The __init__ parameter 'callback' is accepted but never stored or used.",
          "get_dependencies recurses over the unfiltered immediate_dependencies list, so irrelevant phases may still be traversed despite filtering.",
          "The dependency mapping for 'render' includes 'v2_page_images' twice and omits some potential inputs; duplication is only removed later.",
          "Optional phase handling in up_to_date_dict is limited to audio and format_preferences; other optional resources might be misclassified as out of date.",
          "Timestamp handling mixes naive and timezone-aware datetime; timestamp_to_age_in_seconds uses datetime.now().timestamp() which may lead to subtle timezone issues."
        ]
      }
    }
  ],
  "clara_app/clara_diff.py": [
    {
      "created_at": "2025-12-23T11:53:16.401942+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2561,
        "completion_tokens": 1828,
        "total_tokens": 4389,
        "estimated_cost_usd": 0.02148125
      },
      "analysis": {
        "proposed_docstring": "Utility module for comparing two internalised Text objects. It linearises annotated text content into diff elements based on a requested version, uses difflib to align and classify equal, inserted, deleted or substituted elements, and can compute a simple error rate or produce a formatted string highlighting differences. Segment, page and word boundaries are represented explicitly, POS tags are stripped before comparison, and punctuation/layout can be ignored when appropriate.",
        "short_summary": "This module provides functions to diff two Text objects of the same type. It linearises Text instances into sequences of DiffElements, runs difflib.SequenceMatcher to align them, and wraps the output into error rate statistics or a human-readable markup of insertions and deletions. Different versions (plain, segmented, gloss, lemma) affect how boundaries and annotations are handled.",
        "key_responsibilities": [
          "Expose diff_text_objects as the main entry point to compare two Text objects and return requested outputs.",
          "Convert structured Text content into diffable DiffElement lists with appropriate segment, page and word boundary markers.",
          "Use difflib.SequenceMatcher to generate a combined diff element list and classify substitutions, insertions and deletions.",
          "Compute error rates while filtering out whitespace, punctuation and replace-insertions, and format detailed diff output with [deleted]/[inserted] markup of content and annotations."
        ],
        "potential_issues": [
          "diff_elements_to_error_rate is annotated to return a float but actually returns a dict of counts and rate, which may confuse static type checking or callers.",
          "Sequence alignment is performed only on element content, not annotations, which can lead to misalignment or masked annotation differences.",
          "Punctuation and whitespace are ignored in error rate calculations for non-segmented versions, which may underreport differences depending on use case.",
          "POS annotations are stripped before diffing, so POS differences are never reported.",
          "The formatted diff output relies on literal [deleted]/[inserted] markers and '#'-delimited annotations, requiring downstream consumers to parse this markup consistently."
        ]
      }
    }
  ],
  "clara_app/clara_export_import.py": [
    {
      "created_at": "2025-12-23T11:53:39.544735+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 4816,
        "completion_tokens": 1058,
        "total_tokens": 5874,
        "estimated_cost_usd": 0.0166
      },
      "analysis": {
        "proposed_docstring": "Utilities for exporting and importing CLARA projects by packaging project data, media and metadata into a ZIP archive and restoring them into a new project context. The module drives creation of a temporary staging directory, writes global metadata, copies project directories, audio, images and associated metadata, and produces a ZIP file for download. On import it can adjust stored IDs and file paths, and repopulate images, image descriptions and human audio using project methods and the AudioAnnotator while reporting progress via optional callbacks. It also provides helpers to update metadata paths and rename files when a project ID changes.",
        "short_summary": "This module handles exporting a CLARA project into a self-contained ZIP and importing media and metadata from such an archive. It writes global metadata, copies the project directory and associated audio/image data into a temporary directory before zipping. On import it can adjust IDs, update metadata file paths, and add images, image descriptions and human audio back into a project while emitting progress updates.",
        "key_responsibilities": [
          "Build an export ZIP by collecting project directory contents, global metadata, audio metadata (including phonetic variants), images and image descriptions into a temporary staging area and compressing it.",
          "Write JSON metadata files for global project settings, audio, images and image descriptions as part of the export process.",
          "Clean up temporary files and directories used during export.",
          "On import, adjust stored project IDs and file paths in metadata to match a new project, and optionally rename files to canonical names.",
          "Populate a project with imported images, image descriptions, and existing human audio using project APIs and AudioAnnotator, emitting progress updates via callbacks."
        ],
        "potential_issues": [
          "change_project_id_in_imported_directory references a 'callback' variable that is not passed in, which will raise a NameError if the missing project_dir is encountered.",
          "update_images_from_imported_directory assumes keys like 'style_description', 'content_description', etc. exist in metadata; missing keys may raise KeyError.",
          "Some progress messages such as 'Storing human audio for words ({len(words_metadata_for_update)} items)' are not f-strings, so counts will not be interpolated.",
          "Path replacement logic in update_metadata_file_paths assumes a 'clara_content' segment in stored paths; if absent, paths are left unchanged and only a warning is logged.",
          "Export/import routines rely on external helper functions and internal methods (e.g. AudioAnnotator._store_existing_human_audio_mp3s), and may fail if those implementations change or if files are missing."
        ]
      }
    }
  ],
  "clara_app/clara_grapheme_phoneme_align.py": [
    {
      "created_at": "2025-12-23T11:54:13.623854+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2484,
        "completion_tokens": 1870,
        "total_tokens": 4354,
        "estimated_cost_usd": 0.021804999999999998
      },
      "analysis": {
        "proposed_docstring": "Utilities for aligning grapheme strings to phoneme sequences using CLARA lexical resources. It exposes an entry point that consults existing alignments or derives them via a dynamic programming algorithm that leverages known grapheme–phoneme mappings, configurable encoding, and cost heuristics. The module also contains the low-level DP expansion functions and simple tracing toggles to help debug alignment behavior.",
        "short_summary": "This module implements grapheme–phoneme alignment logic against provided lexical resources. It will reuse existing aligned entries, otherwise compute an alignment using a costed dynamic programming search over possible grapheme/phoneme segments. The code supports different phoneme encodings, collects guessed alignments optionally, and includes simple debug tracing.",
        "key_responsibilities": [
          "Provide find_grapheme_phoneme_alignment_using_lexical_resources to fetch an existing aligned entry or compute one from phonetic representations and resource mappings.",
          "Implement dp_phonetic_align and helper functions to perform cost-based dynamic programming over letters and phoneme lists, including handling different encodings and known alignments.",
          "Maintain and update a DP state dictionary and produce aligned grapheme/phoneme strings joined with delimiters.",
          "Expose trace_on/trace_off switches for verbose debugging of the alignment process."
        ],
        "potential_issues": [
          "The global _trace flag toggles shared state and is not thread-safe if used concurrently.",
          "InternalCLARAError is imported but never used, and failures simply print and return None rather than raising, which may obscure errors.",
          "The dynamic programming loops iterate up to range(N + N1), which may miss processing some states or be inefficient for long inputs; cost heuristics and hardcoded penalties are not configurable.",
          "guessed_aligned_entries_dict is mutated as a side effect when provided, which may surprise callers if reused elsewhere."
        ]
      }
    }
  ],
  "clara_app/clara_grapheme_phoneme_resources.py": [
    {
      "created_at": "2025-12-23T11:54:40.243759+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2409,
        "completion_tokens": 1509,
        "total_tokens": 3918,
        "estimated_cost_usd": 0.01810125
      },
      "analysis": {
        "proposed_docstring": "Utilities for accessing and processing grapheme–phoneme resources backed by the ORM phonetic lexicon repository. The module orchestrates retrieval of encoding, plain and aligned lexicon entries for a language or set of words, builds an internalised alignment structure, and exposes helper accessors for consumers of those resources. It includes functions to strip accents from phonetic strings and to parse phoneme strings, combining diacritics appropriately, while posting task progress updates via an optional callback.",
        "short_summary": "This module wraps the ORM phonetic lexicon repository to gather grapheme–phoneme resources. It fetches encoding, plain and aligned entries for a given language/word set and builds an internalised alignment map for downstream use. Helper functions strip accents and parse phoneme strings with diacritics, and can emit progress updates via callbacks.",
        "key_responsibilities": [
          "Check availability of grapheme–phoneme resources for a given language via the phonetic lexicon repository.",
          "Fetch phonetic encoding, plain lexicon entries, aligned entries, and internalised aligned lexicon data for specific words and languages.",
          "Merge new plain entries into existing resource dictionaries and provide accessors for looking up entries within a resource bundle.",
          "Normalize phonetic strings by removing accent markers and parse phoneme strings into lists, combining IPA diacritics appropriately."
        ],
        "potential_issues": [
          "get_encoding returns resources['encoding'] unconditionally because the conditional checks the literal string 'encoding', so it will never return None even if the key is missing.",
          "All repository access creates a new PhoneticLexiconRepositoryORM instance per call; no caching or error handling is present.",
          "Entries with status 'generated' are silently excluded from resource construction; callers may be unaware of missing items.",
          "Warnings in internalise_aligned_grapheme_phoneme_lexicon are printed to stdout rather than raised, and InternalCLARAError is imported but unused."
        ]
      }
    }
  ],
  "clara_app/clara_image_repository_orm.py": [
    {
      "created_at": "2025-12-23T11:55:08.629956+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5828,
        "completion_tokens": 1091,
        "total_tokens": 6919,
        "estimated_cost_usd": 0.018195
      },
      "analysis": {
        "proposed_docstring": "Image repository helper built on the Django ORM for storing image files and their metadata. Provides methods to add, update, retrieve, archive, restore, and delete image records and associated descriptions, while copying files to a configured project directory and generating thumbnails. Interacts with ImageMetadata, ArchivedImageMetadata, and ImageDescription models, wraps file-system utilities, and posts progress messages via an optional callback. Intended as the image counterpart to the audio repository support.",
        "short_summary": "This module implements an ORM-backed repository for images that handles both database metadata and file-system storage. It can add or update image entries, generate and save thumbnails, retrieve images by name or position, and remove or archive entries. It also manages image descriptions and \"understanding\" results for later retrieval.",
        "key_responsibilities": [
          "Initialize and manage a base directory for per-project image storage using configuration settings.",
          "Add, update, retrieve, and delete ImageMetadata records, optionally generating Image objects with thumbnail paths.",
          "Copy source image files into the repository, generate thumbnails with Pillow, and derive project-specific directories.",
          "Maintain and query image descriptions (ImageDescription) and content understanding results tied to description variables.",
          "Archive current image metadata and files, list archived entries, restore archived versions, and delete archived records.",
          "Provide annotated text output of images and associated text in page order for a project."
        ],
        "potential_issues": [
          "remove_entry deletes only the database record and does not remove the corresponding file or thumbnail, leading to orphaned files.",
          "restore_image does not verify that the archived image belongs to the same project_id, and does not clean up the old file paths, which could leave stale files.",
          "Thumbnail generation in store_image always saves using PIL without specifying format; using generate_unique_file_name with a hard-coded PNG extension may mismatch the source format.",
          "Archiving and deletion routines are not wrapped in transactions; errors in file operations or database updates could leave inconsistent state.",
          "delete_archived_image removes the DB row but does not delete any archived file on disk, potentially leaving unused files."
        ]
      }
    }
  ],
  "clara_app/clara_images_utils.py": [
    {
      "created_at": "2025-12-23T11:55:16.982359+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 643,
        "completion_tokens": 575,
        "total_tokens": 1218,
        "estimated_cost_usd": 0.00655375
      },
      "analysis": {
        "proposed_docstring": "Utilities for preparing numbered page lists from project texts for coherent image generation. This module chooses between translated and segmented versions of a project's text, internalises the content, and produces a list of pages annotated with numbering and, optionally, translations depending on project settings.",
        "short_summary": "Provides a helper to generate a numbered page list from a project's textual content for use with images. It selects a translated text version if available, otherwise falls back to a segmented version, internalises the text, and emits page data with translation flags derived from the project.",
        "key_responsibilities": [
          "Select appropriate text version (translated or segmented) from a project for image processing",
          "Internalise raw text content into internal objects using language metadata",
          "Generate numbered page lists via internalised text objects, honouring translation settings"
        ],
        "potential_issues": [
          "Error handling is absent if expected text versions are missing; load_text_version will likely raise",
          "The translation flag is always passed to to_numbered_page_list even when using translated text, which may not reflect intended behaviour",
          "Commented-out code suggests prior handling of original page text when no translation is used; current implementation omits that and may lose original text context"
        ]
      }
    }
  ],
  "clara_app/clara_inflection_tables.py": [
    {
      "created_at": "2025-12-23T11:55:47.574824+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 428,
        "completion_tokens": 1310,
        "total_tokens": 1738,
        "estimated_cost_usd": 0.013635000000000001
      },
      "analysis": {
        "proposed_docstring": "Provide a lookup of external inflection or dictionary URL templates keyed by language and a helper to generate the appropriate link for a given lemma. This module centralizes the supported languages and their URL patterns so other parts of the application can build links to conjugation/definition resources.",
        "short_summary": "This module maintains a mapping of supported languages to external inflection table URL templates. It exposes a helper function that, given a lemma and language key, formats and returns the corresponding lookup URL. If a language is not recognized, the helper returns None.",
        "key_responsibilities": [
          "Define the INFLECTION_TABLE_URLS dictionary mapping language identifiers to URL format strings for external resources",
          "Generate a fully formatted inflection or dictionary URL for a given lemma via get_inflection_table_url",
          "Gracefully handle unsupported languages by returning None instead of a URL"
        ],
        "potential_issues": [
          "Lemma values are interpolated directly without URL encoding, so special characters or spaces may break the link",
          "Language lookup is case-sensitive and requires an exact key match; no normalization is performed",
          "Passing lemmas containing braces or format specifiers could interfere with string formatting",
          "The list of supported languages is hard-coded and includes a commented-out entry; missing or outdated URLs may go unnoticed"
        ]
      }
    }
  ],
  "clara_app/clara_internalise.py": [
    {
      "created_at": "2025-12-23T11:56:04.571594+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3854,
        "completion_tokens": 851,
        "total_tokens": 4705,
        "estimated_cost_usd": 0.013327499999999999
      },
      "analysis": {
        "proposed_docstring": "Utilities for converting externally formatted text into Clara's internal Text/Page/Segment/ContentElement structures. The main entry point, internalize_text, splits an input string into pages and segments, parses words, markup and annotations for various text types (plain, segmented, glossed, lemma-tagged, multi‑word expressions, translated), and constructs annotated objects from clara_classes. Helper routines handle the different segment formats, escape-aware splitting, and validation of regex parsing, raising InternalisationError when content cannot be consumed.",
        "short_summary": "This module parses raw text annotated in Clara's expected markup into Text, Page, Segment and ContentElement instances. It splits input into pages and segments, then interprets words, markup, multi‑word expressions and gloss/tag annotations depending on the supplied text type. Errors in parsing are signaled via InternalisationError.",
        "key_responsibilities": [
          "Provide internalize_text to split input text into pages and segments and build Text/Page objects with annotations.",
          "Parse segment content into ContentElement lists for plain/segmented, glossed/tagged, translated, and MWE formats.",
          "Support escape-aware splitting of annotated strings and validation to detect unparsed portions.",
          "Attach parsed annotations (lemmas, glosses, POS, translations, MWEs) to segments and content elements."
        ],
        "potential_issues": [
          "parse_segment_mwe_trivial uses no_full_analysis/no_minimal_analysis without initialization when prefixes are present, which may raise UnboundLocalError.",
          "Regex patterns for parsing segments are complex and may fail on unexpected markup or leave unaccounted text, triggering InternalisationError.",
          "Parsing logic assumes '||' as segment delimiters and specific page tag format; malformed input may not be handled gracefully.",
          "split_escaped is simplistic and may not correctly handle all backslash escape scenarios or nested escape sequences."
        ]
      }
    }
  ],
  "clara_app/clara_ldt.py": [
    {
      "created_at": "2025-12-23T11:56:40.521435+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 885,
        "completion_tokens": 1729,
        "total_tokens": 2614,
        "estimated_cost_usd": 0.01839625
      },
      "analysis": {
        "proposed_docstring": "Utility helpers to post-process LiteDevTools audio output by converting listed .wav recordings to .mp3 files. The module verifies expected source and destination directories, invokes ffmpeg to perform conversions, updates metadata to point at the new filenames, and uses the shared post_task_update helper to report progress or errors via an optional callback. All processing is wrapped in basic error handling to return an updated metadata list or an empty list on failure.",
        "short_summary": "This module provides a single helper to convert audio files referenced in LiteDevTools metadata from WAV to MP3. It checks for the existence of source and destination directories and files, runs ffmpeg to perform conversions, and updates each metadata entry to the new filename. Progress and errors are communicated through the shared post_task_update callback mechanism.",
        "key_responsibilities": [
          "Validate that the provided WAV and MP3 directories exist before processing LiteDevTools metadata entries.",
          "Iterate over metadata entries to locate source .wav files and construct target .mp3 paths.",
          "Invoke ffmpeg via subprocess to convert audio files when necessary and log status through post_task_update.",
          "Update metadata entries to reference the newly created .mp3 files and report completion or errors."
        ],
        "potential_issues": [
          "Assumes each metadata entry has a \"file\" key; a missing key would raise a KeyError.",
          "Relies on ffmpeg being installed and accessible; the return code is not checked, only the presence of the output file.",
          "The imported file_exists helper is unused, suggesting redundant or incomplete code.",
          "If a destination .mp3 already exists, ffmpeg is skipped without verifying its integrity.",
          "On encountering a missing directory or certain errors the function returns an empty list, discarding any partial progress silently."
        ]
      }
    }
  ],
  "clara_app/clara_main.py": [
    {
      "created_at": "2025-12-23T11:57:00.432923+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 26262,
        "completion_tokens": 801,
        "total_tokens": 27063,
        "estimated_cost_usd": 0.0408375
      },
      "analysis": {
        "proposed_docstring": "Internal utility module defining the CLARAProjectInternal class, which orchestrates the lifecycle of a C-LARA project. It manages project directories, text version files, metadata, and archiving, and wraps calls to ChatGPT and other NLP/TTS/image services to generate, improve, align, and annotate multimodal texts. It also merges annotations, internalises text objects, renders static HTML output (including phonetic variants), handles audio metadata and human alignments, and integrates coherent image generation/storage via an image repository. The class provides helper methods to clone projects, manage images and descriptions, and bridge to asynchronous coherent image workflows.",
        "short_summary": "Encapsulates project-level storage and processing for C-LARA content, handling text versions, metadata, and annotations. Provides methods to generate, improve, align, and merge textual annotations, render annotated HTML, and manage audio and image assets. Acts as a façade over numerous external components (ChatGPT, TTS, TreeTagger, coherent image workflows) to build multimodal language-learning materials.",
        "key_responsibilities": [
          "Create, load, save, archive, and delete project text versions with associated metadata",
          "Internalise and merge annotated texts (segmented, glossed, lemma, pinyin, translation, MWE) and produce rendered HTML outputs",
          "Invoke external services (ChatGPT, TTS, TreeTagger, pypinyin, coherent image generators) to generate or improve content",
          "Align texts to segmented versions, correct syntax, and manage paging for editing and rendering",
          "Manage audio metadata and human/manual alignments, including storage of internalised annotated text pickles",
          "Manage project images, descriptions, advice, and coherent image v2 data, including async workflows for generation and promotion of alternates",
          "Support cloning of projects and copying of text/image data between projects"
        ],
        "potential_issues": [
          "Many try/except blocks swallow exceptions and return empty results, potentially hiding failures and leaving inconsistent state",
          "get_cefr_level returns an empty list when cefr_level is already cached, which may be unintended (should return level and api_calls)",
          "use of asyncio.run within synchronous methods may block event loops if called from async contexts",
          "metadata reconstruction guesses provenance and timestamps and may be inconsistent; _check_metadata_file_consistent is rarely used",
          "remove_v2_page_data calls remove_project_image with self as first argument, likely a bug",
          "align_all_text_versions_with_segmented_and_save and related alignment routines may raise InternalCLARAError; upstream callers must handle",
          "Class-level BASE_DIR is read at import time; config changes at runtime will not propagate"
        ]
      }
    }
  ],
  "clara_app/clara_make_content_zip.py": [
    {
      "created_at": "2025-12-23T11:57:35.526472+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2798,
        "completion_tokens": 1547,
        "total_tokens": 4345,
        "estimated_cost_usd": 0.018967499999999998
      },
      "analysis": {
        "proposed_docstring": "Utility module for packaging rendered project content into a self-contained zip archive. It rewrites image and audio sources in generated HTML pages from served URLs to local \"multimedia\" references, copies the corresponding media files from their repositories, creates a start page, and zips the assembled directory into the project's final zip path. Regular expressions detect media URLs pointing at project image and audio serve endpoints, and Django messages are used to report progress and warnings. The main entry point is build_content_zip_for_text_type, which operates on a project's rendered output for a given text type.",
        "short_summary": "This module builds a zip archive of a project's rendered output, rewriting media references to be self-contained. It scans generated HTML pages, adjusts image and audio source URLs, copies necessary media into a multimedia folder, and creates the final zip file. Progress and errors are reported via Django's messaging framework.",
        "key_responsibilities": [
          "Parse rendered HTML to rewrite <img>, <source>, and <audio> tags that point to serve endpoints so they reference local multimedia files.",
          "Resolve and copy required image files from project-specific image directories and audio files from the configured audio repository into a temporary package directory.",
          "Assemble a temporary content directory with a start page and multimedia assets, then create and place the final zip archive for the project/text type.",
          "Provide feedback on success and missing resources via Django messages."
        ],
        "potential_issues": [
          "Only top-level HTML files whose names start with \"page\" are processed; nested directories or differently named pages will not have media rewritten or copied.",
          "Temporary zip and directory are not explicitly cleaned up, which could leave stray files on disk.",
          "The deduplication set of copied basenames is populated but not used to skip duplicate copy operations.",
          "Media URL rewriting relies on specific URL patterns; unexpected tag structures or alternative endpoints may be missed.",
          "If the audio repository cannot be initialized or files are missing, audio references are rewritten but the actual files may be absent in the archive.",
          "Mixing Path objects and string concatenation for file paths could lead to subtle path issues depending on OS."
        ]
      }
    }
  ],
  "clara_app/clara_manual_audio_align.py": [
    {
      "created_at": "2025-12-23T11:57:57.589605+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1788,
        "completion_tokens": 1542,
        "total_tokens": 3330,
        "estimated_cost_usd": 0.017655
      },
      "analysis": {
        "proposed_docstring": "Utility functions to support C-LARA's manual audio/text alignment workflow. This module transforms annotated segmented text and Audacity label files into alignment metadata, splits a master audio file into per-segment audio clips via ffmpeg, and writes the resulting metadata out. It also contains sample and test helpers for driving the manual alignment integration endpoint.",
        "short_summary": "This module provides helpers for manual audio/text alignment. It can annotate segmented text with indices, combine annotated text and Audacity label files into start/end time metadata, and extract corresponding audio clips using ffmpeg. Sample and test routines are included to generate metadata files and post them to the manual alignment integration endpoint.",
        "key_responsibilities": [
          "Add numeric break markers to segmented text strings for alignment purposes.",
          "Parse annotated segmented text and Audacity label file contents into alignment metadata with start and end times.",
          "Drive ffmpeg via subprocess to extract per-segment audio files from a master audio file based on metadata, reporting progress via callbacks.",
          "Read/write JSON or text representations of metadata and orchestrate conversion of source files into metadata JSON.",
          "Provide sample/test functions to build metadata for known examples and to post alignment data to the manual integration endpoint."
        ],
        "potential_issues": [
          "The ffmpeg subprocess calls are synchronous and may block; failures rely on raising InternalCLARAError without capturing stderr.",
          "No validation that the number of parsed label timestamps matches the number of text segments, which could lead to dropped or misaligned segments.",
          "Hardcoded sample file paths and endpoint URLs in test helpers may not exist in different environments and could leak production endpoints if invoked inadvertently.",
          "This module is not a Django view despite being described as such, and does not interact with models or templates directly, which may confuse maintainers expecting view logic."
        ]
      }
    }
  ],
  "clara_app/clara_merge_glossed_and_tagged.py": [
    {
      "created_at": "2025-12-23T11:58:16.835273+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2641,
        "completion_tokens": 967,
        "total_tokens": 3608,
        "estimated_cost_usd": 0.01297125
      },
      "analysis": {
        "proposed_docstring": "Utilities for combining differently annotated text representations into a unified internal structure. Provides helpers to merge glossed, tagged, pinyin, translation, and multi-word expression annotations by aligning pages, segments, and content elements, as well as a character-level merger that preserves original text while injecting recognized markup tokens. Uses difflib sequence matching to reconcile differing element sequences and merges annotation dictionaries at the element and segment level.",
        "short_summary": "This module merges various annotated Text objects (glossed, tagged, pinyin, translations, MWEs) into a single representation. It aligns pages and segments, matches content elements using difflib, and merges their annotation metadata. It also includes a character-level routine for merging GPT-inserted markup tokens into an original string without altering non-markup characters.",
        "key_responsibilities": [
          "Align two annotated Text objects page-by-page and segment-by-segment and merge their ContentElements and annotations",
          "Provide convenience functions for merging glossed, tagged, pinyin, translation, and MWE-tagged texts using preset dummy annotations",
          "Merge annotation dictionaries from paired elements and segments, preferring second annotations when keys overlap",
          "Support character-wise merging of GPT-inserted markup tokens (<page>, ||, @, |) into an original string based on difflib opcodes"
        ],
        "potential_issues": [
          "merge_annotations1_and_annotations2 uses zip on pages and segments, silently ignoring extra pages/segments if lengths differ",
          "No explicit handling of 'delete' opcodes when comparing content element sequences; deleted items from the second annotation may be ignored",
          "merge_annotations_charwise sets tracing to True by default and prints to stdout, which may be noisy in production",
          "Assumes pages in both texts share annotations; discrepancies are not resolved",
          "Regex-based markup extraction will match each '|' individually and may not handle unexpected markup tokens"
        ]
      }
    }
  ],
  "clara_app/clara_mwe.py": [
    {
      "created_at": "2025-12-23T11:58:49.731301+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1379,
        "completion_tokens": 2001,
        "total_tokens": 3380,
        "estimated_cost_usd": 0.02173375
      },
      "analysis": {
        "proposed_docstring": "Utilities for handling multi‑word expressions (MWEs) within the internal text model, including simplifying MWE‑tagged input, locating MWEs within segments, annotating content elements with MWE metadata, and validating consistency of gloss or lemma annotations across MWE components. Functions operate on page/segment/content element structures produced by internalize_text and report errors via MWEError, optionally posting task updates asynchronously.",
        "short_summary": "This module provides helper functions for processing multi‑word expressions in the internal text representation. It can internalize and simplify MWE‑tagged text, find the positions of MWEs within content elements, and annotate those elements with MWE identifiers, text, and lengths. It also checks that gloss or lemma annotations are consistent across all parts of an MWE, raising MWEError and optionally posting async updates on discrepancies.",
        "key_responsibilities": [
          "Internalize MWE‑tagged text and emit a minimal MWE representation suitable for further processing or display.",
          "Determine positions of MWE token sequences within segments or content element lists, choosing an ordered combination of indices.",
          "Annotate content elements in segments with MWE identifiers, reconstructed MWE text, and lengths based on detected positions.",
          "Validate that gloss or lemma annotations are consistent across all elements of an MWE, posting asynchronous task updates and raising errors when mismatches are detected."
        ],
        "potential_issues": [
          "The callback arguments in several functions are unused or commented out, so progress/error reporting may not occur as intended.",
          "simplify_mwe_tagged_text currently ignores the provided languages by hardcoding them as 'irrelevant', which may affect language‑specific processing.",
          "Finding MWE positions relies solely on string equality and chooses the first minimal‑distance combination; ambiguous MWEs with repeated tokens may not be resolved deterministically.",
          "check_mwes_are_consistently_annotated filters content elements by type before index lookup; if positions were computed on a differently filtered list, indices may not align.",
          "The removal of 'analysis' annotations is commented out in simplify_mwe_tagged_text, so extraneous annotation data may persist unless handled elsewhere."
        ]
      }
    }
  ],
  "clara_app/clara_openai.py": [
    {
      "created_at": "2025-12-23T11:59:04.255252+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2232,
        "completion_tokens": 694,
        "total_tokens": 2926,
        "estimated_cost_usd": 0.009729999999999999
      },
      "analysis": {
        "proposed_docstring": "Utility module providing helpers around OpenAI usage, including listing available models, estimating token usage, and computing cost estimates for text, vision, and image generation calls. It pulls pricing and token-cost configuration from clara_utils and sets the OpenAI API key from the OPENAI_API_KEY environment variable. Functions here encapsulate token counting for messages and strings, image token cost estimation based on dimensions, and pricing logic for various GPT models. Intended for internal use when integrating OpenAI services, rather than serving HTTP requests.",
        "short_summary": "This module wraps OpenAI-related utilities for the application. It sets the OpenAI API key, lists models, counts tokens for messages/strings, estimates image token costs, and calculates cost estimates for text, vision, and image API calls using configured pricing. It relies on clara_utils configuration to determine per-model rates.",
        "key_responsibilities": [
          "Initialize OpenAI API key from environment and expose a helper to list available models.",
          "Compute token counts for chat messages and plain strings using tiktoken for GPT-4 encoding.",
          "Estimate costs for GPT text calls (including reasoning tokens), GPT-4 vision calls, and image generation calls based on model-specific pricing from configuration.",
          "Calculate approximate image token consumption from image dimensions and detail level for vision pricing."
        ],
        "potential_issues": [
          "Pricing logic depends on configuration sections (e.g. chatgpt4_o_costs, o1_costs) that must exist; missing or misnamed config keys will raise exceptions.",
          "Token counting always uses GPT-4 encoding even for other models, which may misestimate cost for differing tokenization.",
          "Default branch in cost_of_gpt4_api_call treats unknown models as GPT-4 and may not reflect actual pricing for newer models.",
          "Setting openai.api_key at import time assumes OPENAI_API_KEY is set; missing env var will cause API calls to fail silently until invoked.",
          "print_openai_models prints to stdout and may not be suitable for production logging.",
          "Image token cost calculation uses integer division and custom heuristics; it may not match actual OpenAI billing."
        ]
      }
    }
  ],
  "clara_app/clara_phonetic_chatgpt4.py": [
    {
      "created_at": "2025-12-23T11:59:36.718821+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1982,
        "completion_tokens": 1888,
        "total_tokens": 3870,
        "estimated_cost_usd": 0.0213575
      },
      "analysis": {
        "proposed_docstring": "Utility functions for driving GPT-4 to generate IPA phonetic transcriptions for a list of words in a given language. The module builds language-specific prompts, chunks input into manageable sizes based on configuration, and orchestrates calls to the ChatGPT-4 client with retry and progress callbacks. Responses are parsed and lightly validated into a word-to-IPA mapping, with task updates posted along the way.",
        "short_summary": "This module wraps ChatGPT-4 interactions to produce phonetic lexicon entries for supplied words. It builds language-specific prompts, splits large inputs into chunks, and retries calls based on configuration while posting status updates. The GPT-4 responses are parsed into a dictionary of IPA annotations for use elsewhere.",
        "key_responsibilities": [
          "Construct language-aware prompts with advice and examples for requesting IPA transcriptions from ChatGPT-4.",
          "Batch input word lists according to configuration and orchestrate multiple GPT-4 calls with retry logic.",
          "Parse and validate GPT-4 JSON responses into word-to-IPA mappings while posting progress via callbacks."
        ],
        "potential_issues": [
          "The `well_formed_element_in_phonetic_lexicon_response` check uses an odd conditional that may accept malformed elements or reject valid ones; it should likely check for list type and length separately.",
          "In `parse_chatgpt_phonetic_lexicon_response` the comparison of the original words to annotated words mixes a list and a joined string and merely assigns an error string without acting on it.",
          "The default `config_info={}` argument is mutable and shared across calls, which can lead to unintended state retention.",
          "The `advice_and_examples` function's default/else branch does not return any string, so non-covered languages may produce prompts missing fallback guidance.",
          "Exceptions during parsing or API errors are logged via `post_task_update` but generally not re-raised, which may mask failures to callers."
        ]
      }
    }
  ],
  "clara_app/clara_phonetic_lexicon_repository_orm.py": [
    {
      "created_at": "2025-12-23T12:00:13.055785+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 6450,
        "completion_tokens": 911,
        "total_tokens": 7361,
        "estimated_cost_usd": 0.0171725
      },
      "analysis": {
        "proposed_docstring": "This module encapsulates ORM-based access to the phonetic lexicon models, providing a repository class for creating, updating, deleting, and querying phonetic encodings and both aligned and plain lexicon entries. It offers convenience methods to initialize lexica from file formats, record generated or reviewed entries, check data consistency, and parse lexicon files in JSON, IPA-dict, or ARPAbet-like text formats. Throughout the operations it reports progress or errors via an optional callback and wraps unexpected exceptions in an internal CLARA error.",
        "short_summary": "Defines a PhoneticLexiconRepositoryORM that wraps Django models for phonetic encodings and lexicon entries. It provides CRUD-style methods for aligned and plain lexicon entries, initialization routines, and file parsing helpers. The module also includes consistency checks and task update callbacks for integration with background jobs.",
        "key_responsibilities": [
          "Manage phonetic encoding settings per language using the PhoneticEncoding model.",
          "Create, update, delete, and query plain and aligned phonetic lexicon entries via Django ORM.",
          "Initialize lexica from uploaded data or parsed files, including support for JSON, IPA-dict, and ARPAbet-like text formats.",
          "Record guessed or reviewed lexicon entries in bulk with status tracking and progress callbacks.",
          "Provide utility functions to parse and validate plain lexicon file content."
        ],
        "potential_issues": [
          "The method plain_phonetic_entries_exist_for_language unconditionally raises an InternalCLARAError after the try/except due to misplaced indentation, causing success cases to still raise.",
          "Several methods are defined twice (e.g. record_guessed_aligned_entries, record_reviewed_aligned_entries, record_aligned_entries, delete_aligned_entries), with the latter definitions silently overriding the earlier ones, which may mask intended behavior or logging.",
          "File parsing assumes specific formats and may return None for malformed lines without reporting which lines were skipped.",
          "Status handling is string-based and not validated against a defined set, which could lead to inconsistent data states.",
          "Bulk operations ignore conflicts, so conflicting entries may be silently skipped without informing the caller."
        ]
      }
    }
  ],
  "clara_app/clara_phonetic_orthography_repository.py": [
    {
      "created_at": "2025-12-23T12:01:23.671655+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2464,
        "completion_tokens": 3436,
        "total_tokens": 5900,
        "estimated_cost_usd": 0.03744
      },
      "analysis": {
        "proposed_docstring": "Helper module for managing CLARA phonetic orthography resources on disk. It wraps a simple repository that ensures a configured base directory exists, saves orthography and accent data for a language into text files, and reads them back either as raw text or parsed structures. Parsing routines understand the repository file formats and can validate structured items, while errors are surfaced via InternalCLARAError and optional task update callbacks.",
        "short_summary": "This module implements a repository for phonetic orthography and accent data backed by a filesystem directory configured in CLARA. It provides methods to write structured orthography/accent definitions to per-language text files, check for their availability, and read them back as either text or parsed objects. Parsing and validation helpers enforce the expected file formats and report errors through InternalCLARAError and optional task callbacks.",
        "key_responsibilities": [
          "Ensure the configured phonetic orthography repository directory exists on initialization.",
          "Persist orthography and accent data for a language to text files and read them back as raw text.",
          "Parse stored orthography and accent files into structured Python objects with optional formatting variants.",
          "Provide consistency checks for orthography and accent items and report issues via callbacks and InternalCLARAError."
        ],
        "potential_issues": [
          "The methods _accents_data_to_text and _accents_item_to_text/_null_accents_item are defined without using self and are referenced without qualification, which will result in NameError or incorrect binding.",
          "consistent_orthography_item returns a bare True instead of a (consistent, error_message) tuple when values are null, deviating from its documented return type.",
          "The condition in consistent_accents_item uses \"or\" instead of \"and\", so values starting with \"u+\" may be erroneously rejected and valid prefixes may fail validation logic.",
          "Error messages in some raised InternalCLARAError instances are not f-string formatted, so they will literally contain placeholders like \"{line}\" instead of the offending line content."
        ]
      }
    }
  ],
  "clara_app/clara_phonetic_text.py": [
    {
      "created_at": "2025-12-23T12:02:00.867304+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3159,
        "completion_tokens": 1845,
        "total_tokens": 5004,
        "estimated_cost_usd": 0.022398750000000002
      },
      "analysis": {
        "proposed_docstring": "Utilities for turning internally segmented text into a phonetic representation using available grapheme–phoneme resources, phonetic orthographies, and external guesses. The module orchestrates loading phonetic orthography data, grapheme-to-phoneme lexica, and calls out to ChatGPT-4 to fill in missing entries, then walks a Text/Page/Segment/ContentElement structure to annotate words with aligned phonetic strings. It includes helper routines for alignment, normalization, and decomposing phonetically spelled languages into annotated segments.",
        "short_summary": "This module converts segmented text objects into phonetic text by aligning graphemes with phonemes using available resources. It can use phonetic orthography definitions, grapheme–phoneme alignment resources, and external ChatGPT guesses to build phonetic annotations for each word, preserving structure and casing. Helpers handle normalization, decomposition of phonetically spelled languages, and tracking guessed entries.",
        "key_responsibilities": [
          "Internalize segmented text and derive available phonetic resources for a given L2 language",
          "Fetch or guess missing grapheme–phoneme entries (including via ChatGPT-4) and augment resources",
          "Convert Text/Page/Segment structures into phonetic counterparts with aligned grapheme and phoneme components annotated on word elements",
          "Provide alignment routines for both lexicon-based and phonetically spelled languages, including normalization and casing transfer"
        ],
        "potential_issues": [
          "The `initial_accent_chars` function references `str` instead of the `string` argument, which will raise an error when processing accent characters",
          "Casing transfer assumes aligned and original word lengths match; mismatches could lead to errors or misaligned casing",
          "Fallback alignment returns '@word@' for words containing spaces, which may be unexpected downstream",
          "No guessed alignments are cached when using phonetic orthography; repeated words may trigger redundant work",
          "External ChatGPT-4 calls are synchronous here and may need error handling or throttling in practice"
        ]
      }
    }
  ],
  "clara_app/clara_phonetic_utils.py": [
    {
      "created_at": "2025-12-23T12:02:15.016439+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 315,
        "completion_tokens": 856,
        "total_tokens": 1171,
        "estimated_cost_usd": 0.00895375
      },
      "analysis": {
        "proposed_docstring": "Utility helpers for phonetic processing that expose a single convenience check for language-specific resources. It bridges between phonetic orthography resources and grapheme–phoneme resources, allowing callers to test if either set is available for a given L2 language code. The module pulls in the underlying repository and availability functions from their respective resource modules.",
        "short_summary": "This module provides a simple utility to determine if phonetic resources are available for a given L2 language. It delegates to checks for both phonetic orthography and grapheme–phoneme resources and returns true if either is present. It imports the underlying repository class and availability functions from companion modules.",
        "key_responsibilities": [
          "Check whether phonetic orthography resources exist for a given target language",
          "Check whether grapheme–phoneme resources exist for a given target language",
          "Provide a consolidated phonetic_resources_are_available helper that returns true if either resource type is available"
        ],
        "potential_issues": [
          "PhoneticOrthographyRepository is imported but not used, which may indicate dead code or a missing usage",
          "No validation or error handling is performed on the l2_language argument; exceptions from underlying availability checks will propagate",
          "The combined availability check assumes an OR is sufficient; callers needing more specific information must use the underlying functions"
        ]
      }
    }
  ],
  "clara_app/clara_prompt_templates.py": [
    {
      "created_at": "2025-12-23T12:02:29.609991+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5780,
        "completion_tokens": 766,
        "total_tokens": 6546,
        "estimated_cost_usd": 0.014885
      },
      "analysis": {
        "proposed_docstring": "Utilities for managing per-language prompt templates and example data used by CLARA’s annotation workflows. The module encapsulates a repository of template and example files on disk, providing methods to load or save current versions, archive previous versions, and maintain metadata about changes. It also provides a suite of validation routines to ensure templates and example data are structurally well-formed for various annotation types and operations before they are persisted. File and content checks leverage internal parsing utilities to guard against malformed inputs and raise informative TemplateError exceptions.",
        "short_summary": "This module implements a prompt template repository that stores and retrieves language-specific templates and example data, archiving older versions and tracking metadata. It validates template content and example lists for different annotation types and operations before loading or saving them. Helper functions parse annotated strings and enforce required placeholders in templates.",
        "key_responsibilities": [
          "Manage storage locations for prompt templates and example files per language, ensuring directories exist.",
          "Load current or archived templates/examples from disk, normalizing line breaks and checking basic shape.",
          "Save new templates/examples, archiving previous versions, and updating a metadata file with timestamps and user information.",
          "Validate templates for required substitution placeholders and example data for structural correctness using internal parsing helpers."
        ],
        "potential_issues": [
          "The comparison in check_improved_morphology_string_against_morphology_string uses improved_example_words incorrectly and compares against a list instead of the individual improved_example string.",
          "In check_validity_of_template for the 'segmented' case, the condition `if not '***examples***' in result or not '***text***' in result in result:` appears to have a typo that could alter validation logic.",
          "check_well_formed_for_saving references an annotation_type 'translated' but other functions use 'translation', suggesting inconsistent annotation type naming.",
          "Error messages such as \"Templatelanguage\" and some TemplateError branches may be uninformative or have minor typos.",
          "No explicit error handling around file system operations means save/load could fail silently outside of validation exceptions."
        ]
      }
    }
  ],
  "clara_app/clara_reading_histories.py": [
    {
      "created_at": "2025-12-23T12:02:48.556087+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2104,
        "completion_tokens": 1140,
        "total_tokens": 3244,
        "estimated_cost_usd": 0.01403
      },
      "analysis": {
        "proposed_docstring": "Internal helper for building and rendering reading histories that concatenate multiple CLARA projects into a single virtual project. Provides a ReadingHistoryInternal class to pull saved internalised and annotated text from component CLARAProjectInternal instances, merge their pages and concordance annotations, and save/render the combined text under a target project. Interfaces with StaticHTMLRenderer to produce static HTML and uses post_task_update callbacks to report progress or errors. Includes utility functions for combining Text objects and concordance data.",
        "short_summary": "This module manages the aggregation of multiple CLARA projects into a single reading history. It retrieves saved internalised/annotated texts from component projects, combines them, saves them to a target project, and can render the combined text to static HTML using StaticHTMLRenderer. Progress and error reporting is done via callbacks with post_task_update, and helper functions merge concordance annotations across texts.",
        "key_responsibilities": [
          "Expose the ReadingHistoryInternal class to manage component CLARAProjectInternal instances and their combined text.",
          "Retrieve saved internalised and annotated Text objects, glue them together, and persist the merged result under a target project.",
          "Incrementally add new component projects to an existing reading history and update the combined text.",
          "Render the combined text to static HTML using StaticHTMLRenderer, optionally handling phonetic variants, and delete rendered output when needed.",
          "Merge pages and concordance annotations from multiple Text objects via combine_text_objects and add_to_concordance helpers."
        ],
        "potential_issues": [
          "The rendered_html_exists method is defined without a self parameter and calls methods with an unexpected self argument, which will raise errors when invoked.",
          "combine_text_objects assumes all Text objects share the same languages and does not validate mismatches, which could lead to inconsistent output.",
          "Error handling broadly catches all exceptions and rethrows ReadingHistoryError, potentially masking underlying causes.",
          "Normal and phonetic HTML existence flags in render_combined_text_object may be inverted, as normal_html_exists is fetched with phonetic=True and vice versa."
        ]
      }
    }
  ],
  "clara_app/clara_registering_utils.py": [
    {
      "created_at": "2025-12-23T12:03:08.354996+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1039,
        "completion_tokens": 935,
        "total_tokens": 1974,
        "estimated_cost_usd": 0.010648749999999998
      },
      "analysis": {
        "proposed_docstring": "Utility helper for registering a CLARA project as a Content entry, including support for phonetic variants and human audio metadata. It loads a project by id, inspects associated human audio configuration, and queries the internal CLARA representation for word counts, voice settings, CEFR level, and summary. A Content record is created or updated with this metadata, falling back to placeholder values if internal data is unavailable. Exceptions are caught and reported via task updates.",
        "short_summary": "Provides a helper to create or update a Content record for a given CLARAProject, optionally handling phonetic text. It gathers human audio preferences, word counts, voice selection, CEFR level, and summary from the internal project data and applies them to the Content. The function ensures the Content title reflects phonetic status and updates existing records if necessary, reporting exceptions via a task update mechanism.",
        "key_responsibilities": [
          "Fetch a CLARAProject by id and instantiate its internal representation",
          "Determine human audio settings and select appropriate voice and audio type for words and segments",
          "Retrieve word count, voice, CEFR level, and summary from the internal project, with fallbacks when unavailable",
          "Create a new Content record with the collected metadata or update an existing one accordingly",
          "Report any exceptions encountered during registration through the task update utility"
        ],
        "potential_issues": [
          "The exception handler calls post_task_update with an undefined callback variable, which will itself raise an error",
          "Errors are broadly caught and swallowed, potentially obscuring failures in content registration",
          "create_update is imported but unused, suggesting leftover or incomplete code",
          "get_object_or_404 will raise an Http404 if the project id is invalid, which may not be handled upstream"
        ]
      }
    }
  ],
  "clara_app/clara_renderer.py": [
    {
      "created_at": "2025-12-23T12:03:31.878851+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 3718,
        "completion_tokens": 944,
        "total_tokens": 4662,
        "estimated_cost_usd": 0.0140875
      },
      "analysis": {
        "proposed_docstring": "Renderer utilities for CLARA that generate static HTML outputs for a Text object and its annotations. This module defines a StaticHTMLRenderer that sets up a Jinja2 template environment, prepares output directories, copies static assets, and renders individual pages, concordance pages, and vocabulary lists, with special handling for questionnaires and optional self-contained builds that bundle multimedia. It also adjusts and copies audio and image file references when producing self-contained exports, and provides helper functions for resolving audio and image paths. Progress updates can be reported via an optional callback.",
        "short_summary": "Provides a StaticHTMLRenderer class that produces static HTML pages for CLARA texts using Jinja2 templates. It prepares output directories, copies static assets and parametrized CSS, and renders pages, concordance entries, and vocabulary lists. When requested, it bundles audio/image assets for a self-contained export and can render a simplified set for questionnaires.",
        "key_responsibilities": [
          "Initialize a template environment and output directory (normal, phonetic, or questionnaire) and copy static assets with parametrized CSS based on format preferences.",
          "Render individual text pages, concordance pages with optional inflection links, and alphabetical/frequency vocabulary list pages using Jinja2 templates.",
          "Optionally adjust audio and image references and copy multimedia files into a bundled directory for self-contained exports.",
          "Provide helper functions to resolve and rewrite audio and image file paths within text page structures, and report progress via callbacks."
        ],
        "potential_issues": [
          "get_top_level_audio_file_path raises InternalCLARAError but the class is not imported in this module, which will raise a NameError.",
          "The progress message when copying files assumes audio but copy_operations may include images; errors are only logged via callback and not propagated.",
          "Deletion of existing output directories is skipped when using S3 storage; stale content may persist in remote storage.",
          "The template directory is read from configuration and must be valid; missing templates (e.g. clara_page.html) will cause runtime errors."
        ]
      }
    }
  ],
  "clara_app/clara_summary.py": [
    {
      "created_at": "2025-12-23T12:04:00.889449+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 583,
        "completion_tokens": 1300,
        "total_tokens": 1883,
        "estimated_cost_usd": 0.01372875
      },
      "analysis": {
        "proposed_docstring": "Utilities for generating and refining brief English summaries of foreign-language texts by crafting prompts and delegating to the ChatGPT-4 API wrapper. Exposes functions that build the appropriate prompt, invoke clara_chatgpt4.call_chat_gpt4, and return the model's response alongside metadata about the API call. Intended to be used by other parts of the application when summarisation of L2 content is needed.",
        "short_summary": "This module wraps calls to ChatGPT-4 to produce short English summaries of texts in a given L2 language. It provides functions to generate a summary from a text or to request an improved version of an existing summary. Each function constructs a prompt, calls the shared API helper, and returns the response with associated API call information.",
        "key_responsibilities": [
          "Capitalize the target language and construct prompts instructing ChatGPT-4 to summarise provided text in English.",
          "Invoke clara_chatgpt4.call_chat_gpt4 with the constructed prompt, optional config, and callback.",
          "Return the generated summary along with a list of APICall instances documenting the request.",
          "Provide an interface to request improvement of an existing summary by supplying both the source text and the previous summary."
        ],
        "potential_issues": [
          "Uses a mutable default argument (config_info={}) which can lead to unexpected state sharing between calls.",
          "The improve_summary prompt labels may be confusing, inserting the full text where it says \"summary to annotate\", which could diminish model performance.",
          "Module docstring references CEFR reading level estimation, which doesn't align with the implemented summarisation functions.",
          "No error handling around API failures; callers must handle exceptions or missing responses from clara_chatgpt4.call_chat_gpt4.",
          "Capitalizing l2_language may mis-handle multi-word or non-Latin language identifiers, potentially affecting prompt clarity."
        ]
      }
    }
  ],
  "clara_app/clara_tts_api.py": [
    {
      "created_at": "2025-12-23T12:04:32.036435+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 7656,
        "completion_tokens": 1379,
        "total_tokens": 9035,
        "estimated_cost_usd": 0.02336
      },
      "analysis": {
        "proposed_docstring": "Provides a collection of text-to-speech engine wrappers for C-LARA, including ReadSpeaker, Google Cloud/gTTS, OpenAI, ABAIR, ElevenLabs, and an IPA reader service. Each engine exposes a common create_mp3() interface and a language/voice catalogue, with helper functions to select an appropriate engine, language ID, and default voice based on requested language, input type, and preference. The module relies on configuration/environment variables for credentials and posts progress/warning messages via the provided callback using post_task_update. Utility functions are exposed to construct engines by type, query supported engines/languages, and pick defaults for downstream processing.",
        "short_summary": "This module wraps multiple third-party TTS providers behind a common interface and selection logic. It defines engine classes for ReadSpeaker, Google Cloud/gTTS, OpenAI, ABAIR, ElevenLabs, and an IPA reader, with hard-coded language/voice maps. Helper functions choose an engine based on language and preferences, derive language IDs and default voices, and report progress through callback updates. External credentials and configuration are read from config and environment variables.",
        "key_responsibilities": [
          "Define TTSEngine subclasses for various providers (ReadSpeaker, Google Cloud/gTTS, OpenAI, ABAIR, ElevenLabs, IPA Reader) with a create_mp3() method to synthesize speech and save it to file.",
          "Maintain static language/voice mappings and selection orderings to pick suitable TTS engines based on language, input type (words/segments), phonetic flag, and preferred provider.",
          "Load provider credentials from configuration or environment (e.g. Google Application Credentials, OPENAI_API_KEY, ELEVEN_LABS_API_KEY) and write temporary credential files when needed.",
          "Expose utility functions to construct engines by type, query supported engines, check language support, and derive default voice and language IDs for a given language.",
          "Report progress and warnings via post_task_update callbacks during synthesis and error handling."
        ],
        "potential_issues": [
          "get_default_voice() assumes a TTS engine was found and immediately dereferences tts_engine.tts_engine_type, which will raise if no engine is available for the language.",
          "OpenAITTSEngine and ElevenLabsEngine access environment variables unguarded; missing keys will raise before any error handling runs.",
          "ReadSpeakerEngine and ABAIREngine do not handle non-200 responses beyond returning False, so callers get no diagnostic detail.",
          "IPAReaderEngine decodes response content using unicode_escape and assumes a base64 payload; API changes or unexpected responses may break decoding.",
          "Google credentials handling writes to /tmp and sets an environment variable globally, which may have side effects in multi-tenant or threaded contexts.",
          "Preferred engine ordering logic in get_tts_engine depends on words_or_segments and phonetic flags; misconfiguration may lead to unexpected engine selection."
        ]
      }
    }
  ],
  "clara_app/clara_universal_dependencies.py": [
    {
      "created_at": "2025-12-23T12:04:55.242156+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2682,
        "completion_tokens": 1220,
        "total_tokens": 3902,
        "estimated_cost_usd": 0.015552499999999999
      },
      "analysis": {
        "proposed_docstring": "Utilities for converting part-of-speech annotations in internalised CLARA texts to Universal Dependencies v2 tags. The main entry point walks an \"internalised_text\" structure (pages, segments, content elements) and rewrites any 'pos' annotation using language-specific mapping functions. Conversion tables for Dutch, English (BNC), French, German TreeTagger, and Italian TreeTagger tagsets are provided, with unsupported languages left unchanged and a warning emitted.",
        "short_summary": "This module converts existing POS tag annotations in an internalised text object to Universal Dependencies v2 tags. It provides a dispatcher and per-language mapping tables for several supported tagsets. The main utility mutates the provided internalised text in place, warning when no conversion is available.",
        "key_responsibilities": [
          "Iterate through an internalised text's pages, segments and content elements to normalize 'pos' annotations to UD v2.",
          "Determine if a given language has a conversion function and route tags to the correct mapping.",
          "Provide mapping tables from various language-specific tagsets (BNC, French, Dutch, German TreeTagger, Italian TreeTagger) to UD POS tags."
        ],
        "potential_issues": [
          "The Italian branch in convert_tag_to_ud_v2 returns the mapping function itself instead of the mapped tag, likely a bug (missing call).",
          "Conversion tables are noted as unrevised and may be incomplete or inaccurate.",
          "Language matching is based on exact lower-case strings; unexpected casing or unsupported languages will trigger only a print warning and leave tags unchanged.",
          "The conversion mutates the passed internalised_text in place and uses print for warnings rather than logging or exceptions.",
          "Default mappings return 'X' or leave tags untouched, which may obscure unhandled tag values."
        ]
      }
    }
  ],
  "clara_app/clara_utils.py": [
    {
      "created_at": "2025-12-23T12:05:23.568356+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 9468,
        "completion_tokens": 1388,
        "total_tokens": 10856,
        "estimated_cost_usd": 0.025715000000000002
      },
      "analysis": {
        "proposed_docstring": "Utility module consolidating common Clara file and path operations across local filesystem and AWS S3 storage. It provides helpers to normalize paths, create/copy/move/remove files and directories, sync directories between S3 and local, read and write JSON/text content, zip/unzip archives, and generate presigned URLs. The utilities also include configuration accessors, simple string helpers, and progress reporting callbacks for long-running tasks, with optional async wrappers for use in async contexts.",
        "short_summary": "This module abstracts file system operations for the Clara app, handling both local paths and S3-backed storage based on configuration. It includes helpers for copying, moving, deleting, and listing files/directories; reading and writing JSON/text; zipping/unzipping; and generating presigned URLs. Additional utilities cover configuration lookup, path manipulation, encoding detection, image dimensions, and task progress callbacks.",
        "key_responsibilities": [
          "Initialize and interact with S3 storage when FILE_STORAGE_TYPE is set, including presigned URL generation and S3/local path normalization.",
          "Perform file and directory operations (copy, move, delete, existence checks, listing) transparently across local and S3 backends.",
          "Read and write JSON and text files with encoding/format handling, including robust encoding detection and checksum verification.",
          "Support zip creation/extraction, download from URLs, image dimension retrieval, and conversion of audio files to MP3 using ffmpeg.",
          "Provide configuration access and various utility functions for path manipulation, string formatting, and posting task updates (sync and async)."
        ],
        "potential_issues": [
          "move_file uses shutil.copyfile without removing the source, so it does not actually move files.",
          "Checksum comparisons against S3 ETag may fail for multipart uploads or large files; MD5 is read into memory in one go.",
          "copytree/make_zipfile/unzip_file assume destination does not exist and may raise if it does; no exist_ok semantics.",
          "report_encoding_error references an undefined _encodingError variable, which will raise if used.",
          "remove_local_directory uses absolute_file_name (honoring S3) rather than absolute_local_file_name, which may be inconsistent with its intent.",
          "Use of global S3 client/session without locking may not be safe in highly concurrent contexts; initialise_s3 is called from multiple functions.",
          "Config path resolution in get_config may double-expand/alter paths if passed through absolute_local_file_name and local_file_exists.",
          "ffmpeg invocation in make_mp3_version_of_audio_file_if_necessary may fail silently if ffmpeg is not installed in the environment."
        ]
      }
    }
  ],
  "clara_app/constants.py": [
    {
      "created_at": "2025-12-23T12:07:56.253319+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2197,
        "completion_tokens": 681,
        "total_tokens": 2878,
        "estimated_cost_usd": 0.00955625
      },
      "analysis": {
        "proposed_docstring": "Centralizes enumerations and configuration constants for the C-LARA application, including text type options, Simple CLARA workflow descriptions, activity categories and statuses, supported languages with AI enablement flags, and various default choices for TTS and image generation features. Derived lists and dictionaries offer convenient lookups and choice tuples for forms, models, and user interfaces. This module serves as a single source of truth for selectable options used throughout the app.",
        "short_summary": "This module defines a collection of choice lists and related constants used across the C-LARA app. It covers text and activity type options, time period defaults, supported languages with AI availability, TTS providers, image generation models, and placeholder texts.",
        "key_responsibilities": [
          "Provide choice tuples for text types, Simple CLARA modes, activity categories, statuses, and resolutions.",
          "Define time period options and defaults for recent activity filtering.",
          "Maintain supported languages metadata, including AI-enabled flags, derived choice lists, and lookup dictionaries.",
          "List supported TTS providers and image generation/model options for coherent images workflows.",
          "Supply placeholder texts and prompt presets for image interpretation and evaluation."
        ],
        "potential_issues": [
          "No validation or synchronization with external services; language codes or model names may drift out of sync with actual support.",
          "Inconsistent naming (e.g. SUPPORTED_PAGE_EVALUATION_PROMPTs with lowercase 's') could lead to typos or import mistakes.",
          "Hard-coded choices require manual updates; missing entries or duplicates could cause UI or form errors.",
          "Derived lists and dictionaries assume the structure of SUPPORTED_LANGUAGES_WITH_AI_ENABLED_STATUS stays consistent."
        ]
      }
    }
  ],
  "clara_app/forms.py": [
    {
      "created_at": "2025-12-23T12:12:37.747616+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 13829,
        "completion_tokens": 1532,
        "total_tokens": 15361,
        "estimated_cost_usd": 0.03260625
      },
      "analysis": {
        "proposed_docstring": "This module centralises the many Django form and formset classes used throughout the C-LARA application. It covers user registration and profile editing, content and project creation/import/export, community membership and permissions, AI-assisted text and image workflows, activity tracking, lexicon/audio metadata, funding requests, and questionnaires. Several forms dynamically adjust choices based on the requesting user or project context and encapsulate custom save/clean logic for password protection, multilingual layout, and coherent image generation parameters. It also declares supporting formsets for bulk operations and dynamic collections of templated strings, examples, and lexicon entries.",
        "short_summary": "Defines the full suite of Django forms for user-facing and administrative workflows in the C-LARA app. Forms span user/profile management, content and project creation/import/export, community assignment, AI-driven text/image generation, activity tracking, lexicon/audio handling, funding, and questionnaires. Some forms adjust their choices at runtime based on the user or project, and a few override save/clean logic to set passwords or validate template variables. Multiple formsets support bulk editing of related items.",
        "key_responsibilities": [
          "Provide user/account forms for registration, password reset, profile and permissions updates, and configuration of AI models and annotation limits.",
          "Support content and project lifecycle via registration/import/export forms, Simple C-LARA workflows, community assignment, membership management, and coherent image settings.",
          "Offer forms for AI-assisted text workflows (generation, segmentation, annotation, translation, glossing, lemma/MWE/pinyin tagging) with RTL handling and archived version selection.",
          "Define image generation/description forms (including coherent images v2 parameters), audio metadata forms, and bulk formsets for image/audio items.",
          "Expose activity, rating/comment, search, voting, and registration forms for issue tracking-like activities.",
          "Manage lexicon and phonetic/audio resources through language-master–filtered forms and formsets for grapheme/phoneme entries and alignment.",
          "Collect funding requests, approval inputs, satisfaction questionnaires, and text questionnaire definitions with custom validation."
        ],
        "potential_issues": [
          "Several form fields build querysets at import time (e.g., UserSelectForm, AssignLanguageMasterForm) which may not reflect current database state or can slow startup.",
          "ProjectCommunityForm accesses project.user before verifying that a project was provided, risking AttributeError if called without a valid project argument.",
          "FundingRequestSearchForm uses boolean choices as strings, which may not coerce cleanly to True/False in filtering logic.",
          "Duplicate or confusing labels/fields for coherent image settings (uses_coherent_image_set and uses_coherent_image_set_v2) could mislead users or conflict in templates.",
          "PromptSelectionForm and PhoneticLexiconForm require a user to populate choices; missing user context will leave required fields empty and may cause validation failures.",
          "Multiple placeholder/pass forms and repeated field definitions (e.g., duplicated import of PhoneticHumanAudioInfo) suggest dead code or maintenance burden."
        ]
      }
    }
  ],
  "clara_app/html_utils.py": [
    {
      "created_at": "2025-12-23T12:14:00.354536+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 2073,
        "completion_tokens": 998,
        "total_tokens": 3071,
        "estimated_cost_usd": 0.012571249999999999
      },
      "analysis": {
        "proposed_docstring": "Utility functions to convert HTML content into readable plain text. Chooses an available BeautifulSoup parser, strips non-content and UI elements, expands ruby annotations, and reconstructs text either by token-aware joining of C‑LARA segments or by fallback extraction. Normalises punctuation spacing, whitespace, and HTML entities to produce clean text output.",
        "short_summary": "Provides helpers for converting HTML to plain text with C‑LARA-specific heuristics. It selects an available BeautifulSoup parser, removes unwanted elements, expands ruby tags, and assembles text from segmented word spans when present. Whitespace and punctuation spacing are tidied before returning unescaped text.",
        "key_responsibilities": [
          "Pick an appropriate BeautifulSoup parser backend from installed options.",
          "Strip headers, footers, scripts, and other non-content elements from a scoped portion of HTML.",
          "Expand ruby annotations into inline representations based on a chosen format.",
          "Join segmented word tokens into coherent text with correct spacing and punctuation handling.",
          "Fallback to generic text extraction with basic newline handling when no token structure is present."
        ],
        "potential_issues": [
          "Module is not a Django view; importing as such may be misleading given its location.",
          "If neither lxml nor html5lib are installed, parsing falls back to the less robust html.parser.",
          "The CSS selectors used to strip elements might remove content if class or tag names overlap with actual text.",
          "Token-joining heuristics may not cover all punctuation or language-specific spacing rules.",
          "Assumes C‑LARA-specific .segment and .word structure; content lacking these may be handled by a less precise fallback."
        ]
      }
    }
  ],
  "clara_app/language_game_generate_images.py": [
    {
      "created_at": "2025-12-23T12:17:01.163725+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 1093,
        "completion_tokens": 1167,
        "total_tokens": 2260,
        "estimated_cost_usd": 0.01303625
      },
      "analysis": {
        "proposed_docstring": "Utilities for generating image assets for a Kok Kaper language game by driving GPT-4 text and image APIs. The module can produce a descriptive style prompt and then asynchronously iterate over combinations of animals, adjectives and body parts defined in a game data JSON file to request and save images. It manages construction of the prompts and output file paths for the generated images, relying on helper functions for API calls and file I/O.",
        "short_summary": "This module builds prompts and invokes GPT-4 services to create image assets for a Kok Kaper language game. It can generate a style description and then asynchronously request images for combinations of animals, adjectives and body parts read from a JSON file, saving the outputs to predefined locations. The functions are structured to run via asyncio helpers rather than through Django request/response handling.",
        "key_responsibilities": [
          "Generate and persist a descriptive image style prompt for the Kok Kaper language game using the ChatGPT API.",
          "Read game data JSON and orchestrate asynchronous creation of image generation tasks for combinations of animals, adjectives, and body parts.",
          "Construct appropriate prompts and file paths and call the GPT-4 image API to generate and save images for each combination.",
          "Provide utility functions to compute absolute and relative image file paths for generated assets."
        ],
        "potential_issues": [
          "Error handling in create_kk_language_game_style uses format() without logging or printing, so exceptions may be silently ignored.",
          "The module assumes environment variables like $CLARA are set and target directories exist; missing or invalid paths will cause failures when reading/writing files.",
          "Asynchronous image generation creates tasks for all combinations up to n_tasks without rate limiting, which could overwhelm the API or resources.",
          "There is no check or creation of output directories before saving images, so file writes may fail if the directory tree is absent."
        ]
      }
    }
  ],
  "clara_app/models.py": [
    {
      "created_at": "2025-12-23T12:19:02.770988+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 10674,
        "completion_tokens": 877,
        "total_tokens": 11551,
        "estimated_cost_usd": 0.0221125
      },
      "analysis": {
        "proposed_docstring": "This module defines the core Django ORM models for the C‑LARA application, covering user profiles and social features, community membership, project lifecycle and permissions, content metadata, audio/image handling, questionnaires, activities, and assorted utility records. It encapsulates relationships between users, language and localization resources, projects and their rendered outputs, along with methods for URL resolution, password protection, and freshness checks on generated archives. Additional models capture ratings, comments, reading history, funding requests, API call logging, asynchronous task updates, phonetic lexica, and text/image questionnaires. Helper methods interact with filesystem utilities for managing rendered project artifacts and zips, and with Django’s auth and contenttypes frameworks for permissions and generic relations.",
        "short_summary": "Defines the database schema for users, projects, content, and community interactions in the C‑LARA app. Models cover social features, localization, project assets and permissions, activity tracking, questionnaires, and multimedia metadata. Includes helper methods for generating URLs, zip paths, and password handling on protected content. Some utilities interact with the filesystem and async task updates.",
        "key_responsibilities": [
          "Model user-related data such as profiles, friend requests, configurations, language mastery, and social updates",
          "Represent projects, their permissions, acknowledgements, formatting preferences, audio/image info, and rendered outputs",
          "Store content metadata with optional password protection, access tracking, ratings, comments, and reading histories",
          "Capture questionnaire responses (satisfaction, image, text), funding requests, and activity registrations/votes/comments",
          "Persist multimedia metadata (audio/image) and phonetic lexica for language processing needs",
          "Provide helper methods for URL resolution, zip freshness checks, and password hashing/checking"
        ],
        "potential_issues": [
          "Duplicate import of django.db.models is redundant",
          "CLARAProject.zip_is_fresh silently returns False on any exception and doesn’t check for missing rendered output dirs, which could mask errors",
          "Content.url will return external_url even if None when no project is set; callers may need to handle missing URLs",
          "Content.check_password returns True when no password_hash is set, which may be unintended if protection was expected",
          "ReadingHistory.add_project/remove_project rely on projects_through queries; concurrency or missing orders could lead to incorrect ordering",
          "Many unique_together constraints (e.g., FriendRequest, SatisfactionQuestionnaire) can raise integrity errors if not handled gracefully",
          "Filesystem utilities are used (absolute_file_name, make_zipfile, etc.), but build_zip is commented out; freshness checks may be the only zip management in use"
        ]
      }
    }
  ],
  "clara_app/save_page_texts_multiple_utils.py": [
    {
      "created_at": "2025-12-23T12:22:25.349652+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 394,
        "completion_tokens": 896,
        "total_tokens": 1290,
        "estimated_cost_usd": 0.009452499999999999
      },
      "analysis": {
        "proposed_docstring": "Utility helper for saving multiple page texts through a Clara project, wrapping the internal save call, recording API interactions, and emitting task progress updates via a callback. It triggers saving of corrected texts with optional AI usage, stores API call metadata for auditing, and posts status messages including errors. Intended to be used as part of asynchronous task workflows within the application.",
        "short_summary": "This module provides a wrapper around Clara's internal save_page_texts_multiple functionality to save batches of page texts for a project. It logs resulting API calls, and posts progress or error updates to a provided callback, likely for async task monitoring. The function coordinates configuration and user context when invoking the internal save operation.",
        "key_responsibilities": [
          "Invoke clara_project_internal.save_page_texts_multiple with user and configuration context to save multiple page texts",
          "Persist API call information associated with the project and user via store_api_calls",
          "Post task update messages to an optional callback to indicate progress or errors"
        ],
        "potential_issues": [
          "traceback.format_exc() is used in the exception handler without importing traceback, which will raise a NameError if triggered",
          "The config_info parameter defaults to a mutable dictionary which can lead to unexpected state sharing between calls",
          "The comment suggests an async function but it is defined synchronously, which may cause confusion in async workflows",
          "Exceptions are caught and only reported via callback without being logged or re-raised, potentially hiding failures"
        ]
      }
    }
  ],
  "clara_app/utils.py": [
    {
      "created_at": "2025-12-23T12:26:11.675496+00:00",
      "model": "gpt-5.1-codex-max",
      "usage": {
        "model": "gpt-5.1-codex-max",
        "prompt_tokens": 5878,
        "completion_tokens": 1229,
        "total_tokens": 7107,
        "estimated_cost_usd": 0.019637500000000002
      },
      "analysis": {
        "proposed_docstring": "Utility and helper functions for the CLARA Django application covering localisation lookup, user configuration and credit accounting, asynchronous task progress reporting, and role-based access decorators for projects and communities. It also wraps email sending for different environments, computes meeting dates, and provides helpers for file handling, friendship updates, and audio preferences. Many functions interact with CLARA models to aggregate API costs, enforce permissions, and check project state. Designed to be used across views and internal processes.",
        "short_summary": "This module centralises a collection of utilities for the CLARA app, including localisation lookups, user configuration defaults, and credit/APICall accounting. It defines decorators to enforce project, language, and community roles, helpers for async task update callbacks, and file upload checksum handling. Additional helpers manage email sending, meeting date computations, friendship updates, and audio info for projects.",
        "key_responsibilities": [
          "Provide localisation lookup via bundled translation data with English fallbacks.",
          "Retrieve user configuration and determine AI language enablement and credit availability.",
          "Aggregate and store API call costs/durations, adjust user credits, and report cost statistics.",
          "Offer decorators and helper checks for project permissions, language master access, and community roles.",
          "Support async task progress reporting through TaskUpdate records and retrieval.",
          "Wrap email sending and date computation utilities for CLARA meetings and environment-specific behavior.",
          "Handle file upload persistence with MD5 validation and expose project audio and dependency status helpers."
        ],
        "potential_issues": [
          "The function `_bundle_dict` is defined twice with the same signature; the first definition is overridden, which may be accidental.",
          "language_master_required uses HttpResponseForbidden but this module does not import it, which would raise a NameError when invoked.",
          "Some functions query related objects in loops or per-item (e.g. bundle.bundleitem_set.get inside a loop), which could be inefficient.",
          "Email sending wrappers only print in non-'unisa' environments, so emails may never be sent outside that context.",
          "Credit balance adjustment functions could double-subtract costs if misused; update_credit_balances simply deducts aggregate costs again."
        ]
      }
    }
  ]
}