#!/usr/bin/env python3

from .clara_utils import (
    read_txt_file,
    write_txt_file,
    absolute_file_name
    )

from .refactor_utils import (
    get_function_names_from_file,
    get_imports_from_file,
    get_functions_called_by_function,
    get_functions_called_in_file,
    get_view_functions_from_urls
    )

import os
import re
import shutil
from pathlib import Path
from redbaron import RedBaron

def test(id):
    if id == 1:
        urls_path = '$CLARA/clara_app/urls.py'
        views_path = '$CLARA/clara_app/views.py'
        new_module_name = 'home_views'
        url_patterns_to_move = 'home,home_page,clara_home_page'
        output_dir = '$CLARA/clara_app'
        modularize_views(
            urls_path,
            views_path,
            new_module_name,
            url_patterns_to_move,
            output_dir)
    elif id == 2:
        print(get_function_names_from_file('$CLARA/clara_app/refactor_utils.py'))
    elif id == 3:
        print(get_functions_called_in_file('$CLARA/clara_app/views.py', 'clara_home_page'))
    elif id == '3a':
        print(get_functions_called_in_file('$CLARA/clara_app/accounts_views.py', 'profile'))
    elif id == 4:
        print(get_function_names_from_file('$CLARA/clara_app/views.py'))
    elif id == 5:
        print(get_view_functions_from_urls('$CLARA/clara_app/urls.py'))

    
def modularize_views(
    urls_path,
    views_path,
    new_module_name,
    url_patterns_to_move,
    output_dir
):
    """
    Moves a set of view functions from views.py into a new module and updates
    urls.py accordingly, using RedBaron-based helpers for parsing.

    :param urls_path: Path to the Django urls.py file
    :param views_path: Path to the current views.py file
    :param new_module_name: Name of the new .py file (without extension) for the moved views
    :param url_patterns_to_move: A list of view function names or the unique identifiers
                                 used in urls.py (i.e., the function part of 'views.some_view')
    :param output_dir: Where to place the newly created module and updated files
    """

    # 1. Read and parse the source code for urls.py and views.py
    output_dir_abs = absolute_file_name(output_dir)

    urls_source = read_txt_file(urls_path)
    views_source = read_txt_file(views_path)

    urls_red = RedBaron(urls_source)
    views_red = RedBaron(views_source)

    # 2. Create the new module file in memory (a RedBaron object to store imports + defs)
    new_module = RedBaron("")
    new_module_node_list = new_module.node_list

    # Grab top-level imports from the old views.py to seed the new module
    # (You may want something more refined, e.g., only copying imports if needed.)
    top_imports = []
    for node in views_red.node_list:
        if node.type in ("import", "from_import"):
            top_imports.append(node.copy())

    # Insert those import statements into the new module
    for imp_node in top_imports:
        new_module_node_list.append(imp_node)

    # Add a comment header
    new_module_node_list.append(new_module._convert_input_to_node(
        f"# Auto-generated by modularize_views\n"
    ))

    # 3. For each function name in url_patterns_to_move, move it to the new module
    #    and update references in urls.py from 'views.fn_name' to 'new_module_name.fn_name'
    moved_functions = []

    for fn_name in url_patterns_to_move:
        # (a) Find the function in views_red
        fn_node = views_red.find("def", name=fn_name)
        if not fn_node:
            print(f"Warning: function '{fn_name}' not found in {views_path}")
            continue

        # (b) Copy the function node and append to the new module
        fn_copy = fn_node.copy()
        new_module_node_list.append(fn_copy)

        # (c) Remove the original from views_red
        fn_node.remove()
        moved_functions.append(fn_name)

        # (d) In urls_red, update references from 'views.fn_name' or 'views.fn_name(...)'
        #     to 'new_module_name.fn_name'
        #     We'll look for atomtrailers referencing 'views.fn_name' specifically.
        #     (We assume standard usage: "views.fn_name")
        for atom in urls_red.find_all("atomtrailers"):
            # If the chain is something like [NameNode('views'), DotNode('.'), NameNode(fn_name)]
            if len(atom.value) == 3:
                if (
                    atom.value[0].type == "name"
                    and atom.value[0].value == "views"
                    and atom.value[1].type == "dot"
                    and atom.value[2].type == "name"
                    and atom.value[2].value == fn_name
                ):
                    # Replace with [NameNode(new_module_name), DotNode('.'), NameNode(fn_name)]
                    atom.value[0].value = new_module_name

    # 4. Write the new module to disk
    new_module_filename = f"{new_module_name}.py"
    new_module_path = output_dir_abs / new_module_filename
    with open(new_module_path, "w", encoding="utf-8") as f:
        f.write(new_module.dumps())

    # 5. Write out the modified urls.py and views.py
    modified_urls_path = output_dir_abs / f"modified_{urls_abs.name}"
    modified_views_path = output_dir_abs / f"modified_{views_abs.name}"

    with open(modified_urls_path, "w", encoding="utf-8") as f:
        f.write(urls_red.dumps())

    with open(modified_views_path, "w", encoding="utf-8") as f:
        f.write(views_red.dumps())

    # 6. Summary
    print(f"Moved functions: {moved_functions}")
    print(f"Created new module: {new_module_path}")
    print(f"Modified urls.py -> {modified_urls_path}")
    print(f"Modified views.py -> {modified_views_path}")

