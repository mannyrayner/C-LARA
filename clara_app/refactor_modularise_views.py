#!/usr/bin/env python3

from .clara_utils import (
    read_txt_file,
    write_txt_file,
    absolute_file_name
    )

import os
import re
import shutil

def test(id):
    if id == 1:
        urls_path = '$CLARA/clara_app/urls.py'
        views_path = '$CLARA/clara_app/views.py'
        new_module_name = 'home'
        url_patterns_to_move = 'home,home_page,clara_home_page'
        output_dir = '$CLARA/clara_app'
        modularize_views(
            urls_path,
            views_path,
            new_module_name,
            url_patterns_to_move,
            output_dir)

def modularize_views(
    urls_path,
    views_path,
    new_module_name,
    url_patterns_to_move,
    output_dir):
    """
    A simple script to move certain views from views.py into a new module,
    and update urls.py accordingly.
    """

    output_dir = absolute_file_name(output_dir)
    url_patterns_to_move = [ item.strip() for item in url_patterns_to_move.split(',') ]

    # 1. Read in the original files
    urls_content = read_txt_file(urls_path)
##    with open(urls_path, 'r', encoding='utf-8') as f:
##        urls_content = f.read()

    views_content = read_txt_file(views_path)
##    with open(views_path, 'r', encoding='utf-8') as f:
##        views_content = f.read()

    # 2. Build a dictionary of { view_function_name: regex_pattern_to_match }
    #    We'll search for lines in urls.py that look like: path('...', views.my_function, ...)
    #    or re_path(...) or anything referencing "views.some_function".
    #    You can adapt to your actual code style if it differs.
    pattern_dict = {}
    for fn in url_patterns_to_move:
        # We'll store the function name, e.g. 'my_function'
        # We'll also create a regex that tries to capture a line referencing: views.my_function
        # This is simplified: it won't catch multi-line path definitions or very unusual spacing.
        pattern_dict[fn] = r'(path|re_path)\([^)]*views\.' + re.escape(fn) + r'[^)]*\)'

    # 3. In urls.py: replace references from 'views.fn_name' to 'new_module_name.fn_name'
    new_urls_content = urls_content
    for fn_name, pattern in pattern_dict.items():
        # For each line matching the pattern, we do a second pass to replace
        # "views.fn_name" with "new_module_name.fn_name"
        new_urls_content = re.sub(
            r'(views\.' + re.escape(fn_name) + r')',
            new_module_name + r'.' + fn_name,
            new_urls_content
        )

    # 4. Extract the code for each function from views.py
    #    We do a naive parse: find "def fn_name(" and then capture until next "def " at the same indent or EOF.
    moved_functions = {}
    for fn_name in url_patterns_to_move:
        # Regex approach for function start:
        # We'll look for something like:  ^def fn_name(
        # Then capture everything until we hit ^def or EOF.
        # This is also a naive approach that may break if your code has nested defs or decorators spread across lines.
        func_pattern = re.compile(
            rf"(\n?def\s+{re.escape(fn_name)}\([^\n]*\n(?:[ \t].*\n)*)",
            re.MULTILINE
        )
        matches = func_pattern.findall(views_content)
        if matches:
            # If there's more than one match, we take the first, but typically you'd only have one definition.
            moved_functions[fn_name] = matches[0]
        else:
            print(f"Warning: function {fn_name} not found in {views_path}")

    # 5. Build the content for the new module
    #    We'll try to guess the necessary imports by scanning for "import" and "from x import y" lines
    #    from the top of views.py. In reality, you'd want to parse more thoroughly or track usage.
    #    We'll just copy all the import lines from the top of views.py for simplicity.
    #    You can refine by checking references within the extracted functions.
    import_lines = []
    lines = views_content.splitlines(True)  # Keep line endings
    for line in lines:
        if line.strip().startswith('import ') or line.strip().startswith('from '):
            import_lines.append(line)
        else:
            # Once we reach a non-import line, stop. This assumes all imports are top-level.
            pass

    # De-duplicate import lines
    import_lines = list(dict.fromkeys(import_lines))

    # 6. Construct the new module content
    new_views_module = []
    new_views_module.append(f"# {new_module_name}.py\n")
    new_views_module.append("# Auto-generated by modularize_views\n\n")
    new_views_module.extend(import_lines)
    new_views_module.append("\n\n# Moved functions:\n")

    for fn_name in url_patterns_to_move:
        fn_code = moved_functions.get(fn_name, "")
        new_views_module.append(fn_code)
        new_views_module.append("\n")

    new_views_module_str = "".join(new_views_module)

    # 7. In views.py, comment out the functions that were moved
    commented_views_content = views_content
    for fn_name, fn_code in moved_functions.items():
        # We'll replace the exact code with a commented version
        # We'll take each line of fn_code and prepend "# ".
        commented_code = "\n".join(["# " + l for l in fn_code.splitlines()])
        commented_views_content = commented_views_content.replace(fn_code, commented_code, 1)

    # 8. Write out the new files
    new_module_path = os.path.join(output_dir, f"{new_module_name}.py")
    modified_urls_path = os.path.join(output_dir, os.path.basename(urls_path))
    modified_views_path = os.path.join(output_dir, os.path.basename(views_path))

    write_txt_file(new_views_module_str, new_module_path)
##    with open(new_module_path, 'w', encoding='utf-8') as f:
##        f.write(new_views_module_str)

    write_txt_file(new_urls_content, modified_urls_path)
##    with open(modified_urls_path, 'w', encoding='utf-8') as f:
##        f.write(new_urls_content)

    write_txt_file(commented_views_content, modified_views_path)
##    with open(modified_views_path, 'w', encoding='utf-8') as f:
##        f.write(commented_views_content)

    print(f"Created new module: {new_module_path}")
    print(f"Modified urls.py -> {modified_urls_path}")
    print(f"Modified views.py -> {modified_views_path}")

##if __name__ == "__main__":
##    # Example usage:
##    # python modularize_views.py /path/to/urls.py /path/to/views.py accounts_views "redirect_login,register,profile"
##    import sys
##
##    if len(sys.argv) != 5:
##        print("Usage: python modularize_views.py <urls_path> <views_path> <new_module_name> <comma_separated_view_functions>")
##        sys.exit(1)
##
##    urls_path_arg = sys.argv[1]
##    views_path_arg = sys.argv[2]
##    new_module_name_arg = sys.argv[3]
##    view_functions_arg = sys.argv[4]
##
##    view_functions = [fn.strip() for fn in view_functions_arg.split(",")]
##
##    modularize_views(
##        urls_path=urls_path_arg,
##        views_path=views_path_arg,
##        new_module_name=new_module_name_arg,
##        url_patterns_to_move=view_functions,
##        output_dir='.'
##    )
